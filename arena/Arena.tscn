[gd_scene load_steps=62 format=2]

[ext_resource path="res://arena/Arena.gd" type="Script" id=1]
[ext_resource path="res://player/Player.tscn" type="PackedScene" id=2]
[ext_resource path="res://resources/tileset_arena.tres" type="TileSet" id=3]
[ext_resource path="res://arena/tempbody.gd" type="Script" id=4]
[ext_resource path="res://resources/graphics/light.png" type="Texture" id=5]
[ext_resource path="res://resources/graphics/pixel.png" type="Texture" id=6]
[ext_resource path="res://resources/graphics/bolt.png" type="Texture" id=7]
[ext_resource path="res://arena/BodiesLayer.gd" type="Script" id=8]
[ext_resource path="res://arena/Effects.gd" type="Script" id=9]
[ext_resource path="res://resources/graphics/tileset_arena_v2.png" type="Texture" id=10]
[ext_resource path="res://gameview/JuicyCamera.tscn" type="PackedScene" id=11]
[ext_resource path="res://resources/graphics/tileset_arena.png" type="Texture" id=12]

[sub_resource type="Shader" id=87]
code = "shader_type canvas_item;
//render_mode blend_premul_alpha; // nč bolš

//blend_mix - Mix blend mode (alpha is transparency), default.
//blend_add - Additive blend mode.
//blend_sub - Subtractive blend mode.
//blend_mul - Multiplicative blend mode.
//blend_premul_alpha - Pre-multiplied alpha blend mode.
//blend_disabled - Disable blending, values (including alpha) are written as-is.
//unshaded - Result is just albedo. No lighting/shading happens in material.
//light_only - Only draw on light pass
//skip_vertex_transform - VERTEX/NORMAL/etc need to be transformed manually in vertex function.



// šejder v1 - prepoznava 100% transparenco in aplicira novo barvo na te pixle
// šejder v2 - prepoznava tudi cutout barvo, ki jo potem manipulira
// šejder v3 - prepoznava barvo, ki ji mora dodat senco
// šejder v4 - prepoznava različne barve, ki jim dodaj različne sence
// šejder v5 - dodaja sence za prizemljene objekte

//... simple nadgradnja je če dodam več barv za manipulirat ... al pa celo gradient

// barve
uniform vec4 manipulate_color : hint_color = vec4(1.0, 0.0, 0.0, 1.0); // select color to regirster and manipulate
uniform bool manipulate_other_colors = true;
uniform vec4 transparent_to_color : hint_color = vec4(0.0, 0.0, 0.0, 0.0); // apply color to texture with alpha 0.0

// shadow
uniform vec4 shadow_color : hint_color = vec4(0.0, 0.0, 0.0, 1.0);
uniform float shadow_offset_x = 1.0; // smer offseta ... to niso texli ampak pixli
uniform float shadow_offset_y = 1.0; // smer offseta ... to niso texli ampak pixli
uniform float texture_altitude = 5.0; // količina offseta ... višin texture

// dimenzija teksture za uskladitev texlov s pixli (1/texture original size)  
uniform float texture_width = 640.0;
uniform float texture_height = 360.0;



void fragment(){

	// preračun pravge offseta sence ... pixle konvertamo v texle
	vec2 shadow_offset = vec2(shadow_offset_x / texture_width, shadow_offset_y / texture_height);
	vec2 uvs = UV + shadow_offset * texture_altitude;
	
	// poberemo prikaz texture in apliciramo samo offset še predno apliciramo barvo 
	vec4 color = texture(TEXTURE, uvs);

	
	// manipuliramo izbrano barvo
	if (manipulate_other_colors == false){
		
		// če je barva texture enaka izbrani apliciramo efekt
		if (color == manipulate_color){
			color = shadow_color * color.a;
		}
		// druge barve so brez efekta
		else {
			color.a = 0.0; // 100% transparenca
			color = texture(TEXTURE, UV); // original barva in pozicija
		}
	}
	
	// manipuliramo vse razen izbrane barve
	else if (manipulate_other_colors == true){
		
		// če barva texture ni transparenta apliciramo efekt
		if (color.a > 0.0){
			
			// barva enaka izbrani barvi je brez efekta
			if (color == manipulate_color){
				color.a = 0.0;
				color = texture(TEXTURE, UV);
			}
			// aplciramo efekt na vse druge barve
			else {
				color = shadow_color * color.a;
			}
		}
		// barva transparentnega dela tekture
		else {
			color = transparent_to_color;
		}
		
	}
	
	COLOR = color;
}"

[sub_resource type="ShaderMaterial" id=88]
shader = SubResource( 87 )
shader_param/manipulate_color = Color( 1, 0, 0, 1 )
shader_param/manipulate_other_colors = true
shader_param/transparent_to_color = Color( 0, 0, 0, 0 )
shader_param/shadow_color = Color( 0, 0, 0, 0.196078 )
shader_param/shadow_offset_x = 0.0
shader_param/shadow_offset_y = 1.0
shader_param/texture_altitude = 6.0
shader_param/texture_width = 640.0
shader_param/texture_height = 360.0

[sub_resource type="ViewportTexture" id=92]
viewport_path = NodePath("EffectsLayer Z1/Viewport")

[sub_resource type="Shader" id=85]
code = "shader_type canvas_item;
render_mode blend_premul_alpha;

//blen


void fragment(){

	COLOR =  texture(TEXTURE, UV);
}"

[sub_resource type="ShaderMaterial" id=86]
shader = SubResource( 85 )

[sub_resource type="ViewportTexture" id=93]
viewport_path = NodePath("EffectsLayer Z1/Viewport")

[sub_resource type="Curve" id=5]
max_value = 5.0
_data = [ Vector2( 0, 0 ), 0.0, 4.14464, 0, 0, Vector2( 1, 1.56198 ), 0.0, 0.0, 0, 0 ]

[sub_resource type="Gradient" id=58]
colors = PoolColorArray( 1, 0, 0, 0.921569, 1, 0, 0, 0 )

[sub_resource type="Shader" id=13]
code = "// NOTE: Shader automatically converted from Godot Engine 3.5.1.stable's ParticlesMaterial.

shader_type particles;
uniform vec3 direction;
uniform float spread;
uniform float flatness;
uniform float initial_linear_velocity;
uniform float initial_angle;
uniform float angular_velocity;
uniform float orbit_velocity;
uniform float linear_accel;
uniform float radial_accel;
uniform float tangent_accel;
uniform float damping;
uniform float scale;
uniform float hue_variation;
uniform float anim_speed;
uniform float anim_offset;
uniform float initial_linear_velocity_random;
uniform float initial_angle_random;
uniform float angular_velocity_random;
uniform float orbit_velocity_random;
uniform float linear_accel_random;
uniform float radial_accel_random;
uniform float tangent_accel_random;
uniform float damping_random;
uniform float scale_random;
uniform float hue_variation_random;
uniform float anim_speed_random;
uniform float anim_offset_random;
uniform float lifetime_randomness;
uniform vec3 emission_box_extents;
uniform vec4 color_value : hint_color;
uniform int trail_divisor;
uniform vec3 gravity;

// dodamo sprajt
uniform sampler2D sprite;


float rand_from_seed(inout uint seed) {
	int k;
	int s = int(seed);
	if (s == 0)
	s = 305420679;
	k = s / 127773;
	s = 16807 * (s - k * 127773) - 2836 * k;
	if (s < 0)
		s += 2147483647;
	seed = uint(s);
	return float(seed % uint(65536)) / 65535.0;
}

float rand_from_seed_m1_p1(inout uint seed) {
	return rand_from_seed(seed) * 2.0 - 1.0;
}

uint hash(uint x) {
	x = ((x >> uint(16)) ^ x) * uint(73244475);
	x = ((x >> uint(16)) ^ x) * uint(73244475);
	x = (x >> uint(16)) ^ x;
	return x;
}

void vertex() {
	uint base_number = NUMBER / uint(trail_divisor);
	uint alt_seed = hash(base_number + uint(1) + RANDOM_SEED);
	float angle_rand = rand_from_seed(alt_seed);
	float scale_rand = rand_from_seed(alt_seed);
	float hue_rot_rand = rand_from_seed(alt_seed);
	float anim_offset_rand = rand_from_seed(alt_seed);
	float pi = 3.14159;
	float degree_to_rad = pi / 180.0;

	bool restart = false;
	float tv = 0.0;
	if (CUSTOM.y > CUSTOM.w) {
		restart = true;
		tv = 1.0;
	}

	if (RESTART || restart) {
		uint alt_restart_seed = hash(base_number + uint(301184) + RANDOM_SEED);
		float tex_linear_velocity = 0.0;
		float tex_angle = 0.0;
		float tex_anim_offset = 0.0;
		float spread_rad = spread * degree_to_rad;
		{
			float angle1_rad = rand_from_seed_m1_p1(alt_restart_seed) * spread_rad;
			angle1_rad += direction.x != 0.0 ? atan(direction.y, direction.x) : sign(direction.y) * (pi / 2.0);
			vec3 rot = vec3(cos(angle1_rad), sin(angle1_rad), 0.0);
			VELOCITY = rot * initial_linear_velocity * mix(1.0, rand_from_seed(alt_restart_seed), initial_linear_velocity_random);
		}
		float base_angle = (initial_angle + tex_angle) * mix(1.0, angle_rand, initial_angle_random);
		CUSTOM.x = base_angle * degree_to_rad;
		CUSTOM.y = 0.0;
		CUSTOM.w = (1.0 - lifetime_randomness * rand_from_seed(alt_restart_seed));
		CUSTOM.z = (anim_offset + tex_anim_offset) * mix(1.0, anim_offset_rand, anim_offset_random);
		TRANSFORM[3].xyz = vec3(rand_from_seed(alt_restart_seed) * 2.0 - 1.0, rand_from_seed(alt_restart_seed) * 2.0 - 1.0, rand_from_seed(alt_restart_seed) * 2.0 - 1.0) * emission_box_extents;
		VELOCITY = (EMISSION_TRANSFORM * vec4(VELOCITY, 0.0)).xyz;
		TRANSFORM = EMISSION_TRANSFORM * TRANSFORM;
		VELOCITY.z = 0.0;
		TRANSFORM[3].z = 0.0;
		
		
		// za barvno mimiko moramo \"translate between particle coordinates and uv coordinates
		// pozicija partiklov
		vec2 particlePosition = TRANSFORM[3].xy; // pozicija je shranjena v 3. kolumni transform matrix (obsidian \"particles transform matrix\")
		// velikost teksture
		vec2 textureS = vec2(textureSize(sprite, 0));
		// grebamo barve na sprajtu
		vec4 spriteColor = texture(sprite, particlePosition / textureS + vec2(0.5, 0.5)); // pozicijo partikla delimo z velikostjo texture in dodamo origin (trenutno na sredini)
		COLOR = spriteColor;
		
		// explosion efekt 
		VELOCITY.xy = particlePosition * initial_linear_velocity;// move all from the origin
		
		// \"odstrani\" transparentne partikle
		if (spriteColor.a == 0.0)
		{
			ACTIVE = false;
		}
		
		
	} else {
		CUSTOM.y += DELTA / LIFETIME;
		tv = CUSTOM.y / CUSTOM.w;
		float tex_linear_velocity = 0.0;
		float tex_orbit_velocity = 0.0;
		float tex_angular_velocity = 0.0;
		float tex_linear_accel = 0.0;
		float tex_radial_accel = 0.0;
		float tex_tangent_accel = 0.0;
		float tex_damping = 0.0;
		float tex_angle = 0.0;
		float tex_anim_speed = 0.0;
		float tex_anim_offset = 0.0;
		vec3 force = gravity;
		vec3 pos = TRANSFORM[3].xyz;
		pos.z = 0.0;
		// apply linear acceleration
		force += length(VELOCITY) > 0.0 ? normalize(VELOCITY) * (linear_accel + tex_linear_accel) * mix(1.0, rand_from_seed(alt_seed), linear_accel_random) : vec3(0.0);
		// apply radial acceleration
		vec3 org = EMISSION_TRANSFORM[3].xyz;
		vec3 diff = pos - org;
		force += length(diff) > 0.0 ? normalize(diff) * (radial_accel + tex_radial_accel) * mix(1.0, rand_from_seed(alt_seed), radial_accel_random) : vec3(0.0);
		// apply tangential acceleration;
		force += length(diff.yx) > 0.0 ? vec3(normalize(diff.yx * vec2(-1.0, 1.0)), 0.0) * ((tangent_accel + tex_tangent_accel) * mix(1.0, rand_from_seed(alt_seed), tangent_accel_random)) : vec3(0.0);
		// apply attractor forces
		VELOCITY += force * DELTA;
		// orbit velocity
		float orbit_amount = (orbit_velocity + tex_orbit_velocity) * mix(1.0, rand_from_seed(alt_seed), orbit_velocity_random);
		if (orbit_amount != 0.0) {
		     float ang = orbit_amount * DELTA * pi * 2.0;
		     mat2 rot = mat2(vec2(cos(ang), -sin(ang)), vec2(sin(ang), cos(ang)));
		     TRANSFORM[3].xy -= diff.xy;
		     TRANSFORM[3].xy += rot * diff.xy;
		}
		if (damping + tex_damping > 0.0) {
			float v = length(VELOCITY);
			float damp = (damping + tex_damping) * mix(1.0, rand_from_seed(alt_seed), damping_random);
			v -= damp * DELTA;
			if (v < 0.0) {
				VELOCITY = vec3(0.0);
			} else {
				VELOCITY = normalize(VELOCITY) * v;
			}
		}
		float base_angle = (initial_angle + tex_angle) * mix(1.0, angle_rand, initial_angle_random);
		base_angle += CUSTOM.y * LIFETIME * (angular_velocity + tex_angular_velocity) * mix(1.0, rand_from_seed(alt_seed) * 2.0 - 1.0, angular_velocity_random);
		CUSTOM.x = base_angle * degree_to_rad;
		CUSTOM.z = (anim_offset + tex_anim_offset) * mix(1.0, anim_offset_rand, anim_offset_random) + tv * (anim_speed + tex_anim_speed) * mix(1.0, rand_from_seed(alt_seed), anim_speed_random);
	}
	float tex_scale = 1.0;
	float tex_hue_variation = 0.0;
	
//	odstranjena barvna sekcija, ker bomo uporabili sprajt
//
//	float hue_rot_angle = (hue_variation + tex_hue_variation) * pi * 2.0 * mix(1.0, hue_rot_rand * 2.0 - 1.0, hue_variation_random);
//	float hue_rot_c = cos(hue_rot_angle);
//	float hue_rot_s = sin(hue_rot_angle);
//	mat4 hue_rot_mat = mat4(vec4(0.299, 0.587, 0.114, 0.0),
//			vec4(0.299, 0.587, 0.114, 0.0),
//			vec4(0.299, 0.587, 0.114, 0.0),
//			vec4(0.000, 0.000, 0.000, 1.0)) +
//		mat4(vec4(0.701, -0.587, -0.114, 0.0),
//			vec4(-0.299, 0.413, -0.114, 0.0),
//			vec4(-0.300, -0.588, 0.886, 0.0),
//			vec4(0.000, 0.000, 0.000, 0.0)) * hue_rot_c +
//		mat4(vec4(0.168, 0.330, -0.497, 0.0),
//			vec4(-0.328, 0.035,  0.292, 0.0),
//			vec4(1.250, -1.050, -0.203, 0.0),
//			vec4(0.000, 0.000, 0.000, 0.0)) * hue_rot_s;
//	COLOR = hue_rot_mat * color_value;

	TRANSFORM[0] = vec4(cos(CUSTOM.x), -sin(CUSTOM.x), 0.0, 0.0);
	TRANSFORM[1] = vec4(sin(CUSTOM.x), cos(CUSTOM.x), 0.0, 0.0);
	TRANSFORM[2] = vec4(0.0, 0.0, 1.0, 0.0);
	float base_scale = tex_scale * mix(scale, 1.0, scale_random * scale_rand);
	if (base_scale < 0.000001) {
		base_scale = 0.000001;
	}
	TRANSFORM[0].xyz *= base_scale;
	TRANSFORM[1].xyz *= base_scale;
	TRANSFORM[2].xyz *= base_scale;
	VELOCITY.z = 0.0;
	
	// linearno povečamo transparenco ... lahko bi lelali tudi s uniform krivuljami
	if(COLOR.a > 0.0)
	{
		COLOR.a -= 1.0 / LIFETIME * DELTA;
	}
	
	
	TRANSFORM[3].z = 0.0;
	if (CUSTOM.y > CUSTOM.w) {		ACTIVE = false;
	}
}

"

[sub_resource type="ShaderMaterial" id=7]
shader = SubResource( 13 )
shader_param/direction = Vector3( 1, 0, 0 )
shader_param/spread = 0.0
shader_param/flatness = 0.0
shader_param/initial_linear_velocity = 10.0
shader_param/initial_angle = 0.037
shader_param/angular_velocity = -0.053
shader_param/orbit_velocity = 0.0
shader_param/linear_accel = 0.114
shader_param/radial_accel = 1.607
shader_param/tangent_accel = 0.575
shader_param/damping = 0.018
shader_param/scale = 1.035
shader_param/hue_variation = 0.363
shader_param/anim_speed = 0.0
shader_param/anim_offset = 0.0
shader_param/initial_linear_velocity_random = 1.294
shader_param/initial_angle_random = 0.592
shader_param/angular_velocity_random = 0.714
shader_param/orbit_velocity_random = 0.221
shader_param/linear_accel_random = 1.034
shader_param/radial_accel_random = 1.086
shader_param/tangent_accel_random = 1.143
shader_param/damping_random = 0.413
shader_param/scale_random = 0.109
shader_param/hue_variation_random = 0.285
shader_param/anim_speed_random = 0.614
shader_param/anim_offset_random = 0.476
shader_param/lifetime_randomness = 1.049
shader_param/emission_box_extents = Vector3( 4, 4, 0 )
shader_param/color_value = Color( 1, 1, 1, 1 )
shader_param/trail_divisor = 1
shader_param/gravity = Vector3( 0, -1e-06, 0 )
shader_param/sprite = ExtResource( 7 )

[sub_resource type="Shader" id=6]
code = "// NOTE: Shader automatically converted from Godot Engine 3.5.1.stable's ParticlesMaterial.

shader_type particles;


uniform vec3 direction;
uniform float spread;
uniform float flatness;
uniform float initial_linear_velocity;
uniform float initial_angle;
uniform float angular_velocity;
uniform float orbit_velocity;
uniform float linear_accel;
uniform float radial_accel;
uniform float tangent_accel;
uniform float damping;
uniform float scale;
uniform float hue_variation;
uniform float anim_speed;
uniform float anim_offset;
uniform float initial_linear_velocity_random;
uniform float initial_angle_random;
uniform float angular_velocity_random;
uniform float orbit_velocity_random;
uniform float linear_accel_random;
uniform float radial_accel_random;
uniform float tangent_accel_random;
uniform float damping_random;
uniform float scale_random;
uniform float hue_variation_random;
uniform float anim_speed_random;
uniform float anim_offset_random;
uniform float lifetime_randomness;
uniform vec3 emission_box_extents;
uniform vec4 color_value : hint_color;
uniform int trail_divisor;
uniform vec3 gravity;

// dodamo sprajt
uniform sampler2D sprite;


float rand_from_seed(inout uint seed) {
	int k;
	int s = int(seed);
	if (s == 0)
	s = 305420679;
	k = s / 127773;
	s = 16807 * (s - k * 127773) - 2836 * k;
	if (s < 0)
		s += 2147483647;
	seed = uint(s);
	return float(seed % uint(65536)) / 65535.0;
}

float rand_from_seed_m1_p1(inout uint seed) {
	return rand_from_seed(seed) * 2.0 - 1.0;
}

uint hash(uint x) {
	x = ((x >> uint(16)) ^ x) * uint(73244475);
	x = ((x >> uint(16)) ^ x) * uint(73244475);
	x = (x >> uint(16)) ^ x;
	return x;
}

void vertex() {
	uint base_number = NUMBER / uint(trail_divisor);
	uint alt_seed = hash(base_number + uint(1) + RANDOM_SEED);
	float angle_rand = rand_from_seed(alt_seed);
	float scale_rand = rand_from_seed(alt_seed);
	float hue_rot_rand = rand_from_seed(alt_seed);
	float anim_offset_rand = rand_from_seed(alt_seed);
	float pi = 3.14159;
	float degree_to_rad = pi / 180.0;

	bool restart = false;
	float tv = 0.0;
	if (CUSTOM.y > CUSTOM.w) {
		restart = true;
		tv = 1.0;
	}

	if (RESTART || restart) {
		uint alt_restart_seed = hash(base_number + uint(301184) + RANDOM_SEED);
		float tex_linear_velocity = 0.0;
		float tex_angle = 0.0;
		float tex_anim_offset = 0.0;
		float spread_rad = spread * degree_to_rad;
		{
			float angle1_rad = rand_from_seed_m1_p1(alt_restart_seed) * spread_rad;
			angle1_rad += direction.x != 0.0 ? atan(direction.y, direction.x) : sign(direction.y) * (pi / 2.0);
			vec3 rot = vec3(cos(angle1_rad), sin(angle1_rad), 0.0);
			VELOCITY = rot * initial_linear_velocity * mix(1.0, rand_from_seed(alt_restart_seed), initial_linear_velocity_random);
		}
		float base_angle = (initial_angle + tex_angle) * mix(1.0, angle_rand, initial_angle_random);
		CUSTOM.x = base_angle * degree_to_rad;
		CUSTOM.y = 0.0;
		CUSTOM.w = (1.0 - lifetime_randomness * rand_from_seed(alt_restart_seed));
		CUSTOM.z = (anim_offset + tex_anim_offset) * mix(1.0, anim_offset_rand, anim_offset_random);
		TRANSFORM[3].xyz = vec3(rand_from_seed(alt_restart_seed) * 2.0 - 1.0, rand_from_seed(alt_restart_seed) * 2.0 - 1.0, rand_from_seed(alt_restart_seed) * 2.0 - 1.0) * emission_box_extents;
		VELOCITY = (EMISSION_TRANSFORM * vec4(VELOCITY, 0.0)).xyz;
		TRANSFORM = EMISSION_TRANSFORM * TRANSFORM;
		VELOCITY.z = 0.0;
		TRANSFORM[3].z = 0.0;
		
		
		// za barvno mimiko moramo \"translate between particle coordinates and uv coordinates
		// pozicija partiklov
		vec2 particlePosition = TRANSFORM[3].xy; // pozicija je shranjena v 3. kolumni transform matrix (obsidian \"particles transform matrix\")
		// velikost teksture
		vec2 textureS = vec2(textureSize(sprite, 0));
		vec2 targetPosition = round(textureS * particlePosition / ( 2.0 * emission_box_extents.xy));
		vec2 spriteUV = targetPosition / textureS + vec2(0.5,0.5);
		// grebamo barve na sprajtu
		vec4 spriteColor = texture(sprite, spriteUV); // pozicijo partikla delimo z velikostjo texture in dodamo origin (trenutno na sredini)
		COLOR = spriteColor;
		
		// explosion efekt 
//		VELOCITY.xy = particlePosition * initial_linear_velocity;// move all from the origin
		VELOCITY.xy = (targetPosition - particlePosition) * initial_linear_velocity / LIFETIME;// move all from the origin
		
		// \"odstrani\" transparentne partikle
		if (spriteColor.a == 0.0)
		{
			ACTIVE = false;
		}

	} else {
		CUSTOM.y += DELTA / LIFETIME;
		tv = CUSTOM.y / CUSTOM.w;
		float tex_linear_velocity = 0.0;
		float tex_orbit_velocity = 0.0;
		float tex_angular_velocity = 0.0;
		float tex_linear_accel = 0.0;
		float tex_radial_accel = 0.0;
		float tex_tangent_accel = 0.0;
		float tex_damping = 0.0;
		float tex_angle = 0.0;
		float tex_anim_speed = 0.0;
		float tex_anim_offset = 0.0;
		vec3 force = gravity;
		vec3 pos = TRANSFORM[3].xyz;
		pos.z = 0.0;
		// apply linear acceleration
		force += length(VELOCITY) > 0.0 ? normalize(VELOCITY) * (linear_accel + tex_linear_accel) * mix(1.0, rand_from_seed(alt_seed), linear_accel_random) : vec3(0.0);
		// apply radial acceleration
		vec3 org = EMISSION_TRANSFORM[3].xyz;
		vec3 diff = pos - org;
		force += length(diff) > 0.0 ? normalize(diff) * (radial_accel + tex_radial_accel) * mix(1.0, rand_from_seed(alt_seed), radial_accel_random) : vec3(0.0);
		// apply tangential acceleration;
		force += length(diff.yx) > 0.0 ? vec3(normalize(diff.yx * vec2(-1.0, 1.0)), 0.0) * ((tangent_accel + tex_tangent_accel) * mix(1.0, rand_from_seed(alt_seed), tangent_accel_random)) : vec3(0.0);
		// apply attractor forces
		VELOCITY += force * DELTA;
		// orbit velocity
		float orbit_amount = (orbit_velocity + tex_orbit_velocity) * mix(1.0, rand_from_seed(alt_seed), orbit_velocity_random);
		if (orbit_amount != 0.0) {
		     float ang = orbit_amount * DELTA * pi * 2.0;
		     mat2 rot = mat2(vec2(cos(ang), -sin(ang)), vec2(sin(ang), cos(ang)));
		     TRANSFORM[3].xy -= diff.xy;
		     TRANSFORM[3].xy += rot * diff.xy;
		}
		if (damping + tex_damping > 0.0) {
			float v = length(VELOCITY);
			float damp = (damping + tex_damping) * mix(1.0, rand_from_seed(alt_seed), damping_random);
			v -= damp * DELTA;
			if (v < 0.0) {
				VELOCITY = vec3(0.0);
			} else {
				VELOCITY = normalize(VELOCITY) * v;
			}
		}
		float base_angle = (initial_angle + tex_angle) * mix(1.0, angle_rand, initial_angle_random);
		base_angle += CUSTOM.y * LIFETIME * (angular_velocity + tex_angular_velocity) * mix(1.0, rand_from_seed(alt_seed) * 2.0 - 1.0, angular_velocity_random);
		CUSTOM.x = base_angle * degree_to_rad;
		CUSTOM.z = (anim_offset + tex_anim_offset) * mix(1.0, anim_offset_rand, anim_offset_random) + tv * (anim_speed + tex_anim_speed) * mix(1.0, rand_from_seed(alt_seed), anim_speed_random);
	}
	float tex_scale = 1.0;
	float tex_hue_variation = 0.0;
	
//	odstranjena barvna sekcija, ker bomo uporabili sprajt
//
//	float hue_rot_angle = (hue_variation + tex_hue_variation) * pi * 2.0 * mix(1.0, hue_rot_rand * 2.0 - 1.0, hue_variation_random);
//	float hue_rot_c = cos(hue_rot_angle);
//	float hue_rot_s = sin(hue_rot_angle);
//	mat4 hue_rot_mat = mat4(vec4(0.299, 0.587, 0.114, 0.0),
//			vec4(0.299, 0.587, 0.114, 0.0),
//			vec4(0.299, 0.587, 0.114, 0.0),
//			vec4(0.000, 0.000, 0.000, 1.0)) +
//		mat4(vec4(0.701, -0.587, -0.114, 0.0),
//			vec4(-0.299, 0.413, -0.114, 0.0),
//			vec4(-0.300, -0.588, 0.886, 0.0),
//			vec4(0.000, 0.000, 0.000, 0.0)) * hue_rot_c +
//		mat4(vec4(0.168, 0.330, -0.497, 0.0),
//			vec4(-0.328, 0.035,  0.292, 0.0),
//			vec4(1.250, -1.050, -0.203, 0.0),
//			vec4(0.000, 0.000, 0.000, 0.0)) * hue_rot_s;
//	COLOR = hue_rot_mat * color_value;

	TRANSFORM[0] = vec4(cos(CUSTOM.x), -sin(CUSTOM.x), 0.0, 0.0);
	TRANSFORM[1] = vec4(sin(CUSTOM.x), cos(CUSTOM.x), 0.0, 0.0);
	TRANSFORM[2] = vec4(0.0, 0.0, 1.0, 0.0);
	float base_scale = tex_scale * mix(scale, 1.0, scale_random * scale_rand);
	if (base_scale < 0.000001) {
		base_scale = 0.000001;
	}
	TRANSFORM[0].xyz *= base_scale;
	TRANSFORM[1].xyz *= base_scale;
	TRANSFORM[2].xyz *= base_scale;
	VELOCITY.z = 0.0;
	
	// linearno povečamo transparenco ... lahko bi lelali tudi s uniform krivuljami
	if(COLOR.a > 0.0)
	{
		COLOR.a -= 1.0 / LIFETIME * DELTA;
	}
	
	
	TRANSFORM[3].z = 0.0;
	if (CUSTOM.y > CUSTOM.w) {		ACTIVE = false;
	}
}

"

[sub_resource type="ShaderMaterial" id=14]
shader = SubResource( 6 )
shader_param/direction = Vector3( 1, 0, 0 )
shader_param/spread = 0.0
shader_param/flatness = 0.0
shader_param/initial_linear_velocity = 0.0
shader_param/initial_angle = 0.037
shader_param/angular_velocity = -0.053
shader_param/orbit_velocity = 0.0
shader_param/linear_accel = 0.114
shader_param/radial_accel = 1.607
shader_param/tangent_accel = 0.575
shader_param/damping = 0.018
shader_param/scale = 1.035
shader_param/hue_variation = 0.363
shader_param/anim_speed = 0.0
shader_param/anim_offset = 0.0
shader_param/initial_linear_velocity_random = 1.294
shader_param/initial_angle_random = 0.592
shader_param/angular_velocity_random = 0.714
shader_param/orbit_velocity_random = 0.221
shader_param/linear_accel_random = 1.034
shader_param/radial_accel_random = 1.086
shader_param/tangent_accel_random = 1.143
shader_param/damping_random = 0.413
shader_param/scale_random = 0.109
shader_param/hue_variation_random = 0.285
shader_param/anim_speed_random = 0.614
shader_param/anim_offset_random = 0.476
shader_param/lifetime_randomness = 1.049
shader_param/emission_box_extents = Vector3( 40, 40, 0 )
shader_param/color_value = Color( 1, 1, 1, 1 )
shader_param/trail_divisor = 1
shader_param/gravity = Vector3( 0, -1e-06, 0 )
shader_param/sprite = ExtResource( 7 )

[sub_resource type="Curve" id=9]
min_value = -200.0
max_value = 200.0
_data = [ Vector2( 0.08, 146.818 ), 0.0, 57.8063, 0, 1, Vector2( 1, 200 ), 57.8063, 0.0, 1, 0 ]

[sub_resource type="Gradient" id=10]
offsets = PoolRealArray( 0, 0.129199, 1 )
colors = PoolColorArray( 1, 1, 1, 1, 1, 1, 1, 0.0775194, 1, 1, 1, 0 )

[sub_resource type="Shader" id=61]
code = "shader_type canvas_item;

// šejder v1 - prepoznava 100% transparenco in aplicira novo barvo na te pixle
// šejder v2 - prepoznava tudi cutout barvo, ki jo potem manipulira
// šejder v3 - prepoznava barvo, ki ji mora dodat senco
// šejder v4 - prepoznava različne barve, ki jim dodaj različne sence
// šejder v5 - dodaja sence za prizemljene objekte

//... simple nadgradnja je če dodam več barv za manipulirat ... al pa celo gradient

// barve
uniform vec4 manipulate_color : hint_color = vec4(1.0, 0.0, 0.0, 1.0); // select color to regirster and manipulate
uniform bool manipulate_other_colors = true;
uniform vec4 transparent_color : hint_color = vec4(0.0, 0.0, 0.0, 0.0); // apply color to texture with alpha 0.0
uniform vec4 transparent_new_color : hint_color = vec4(0.0, 0.0, 0.0, 0.0); // apply color to texture with alpha 0.0

// shadow
uniform vec4 shadow_color : hint_color = vec4(0.0, 0.0, 0.0, 1.0);
uniform float shadow_offset_x = 1.0; // smer offseta ... to niso texli ampak pixli
uniform float shadow_offset_y = 1.0; // smer offseta ... to niso texli ampak pixli
uniform float texture_altitude = 5.0; // količina offseta ... višin texture

// dimenzija teksture za uskladitev texlov s pixli (1/texture original size)  
uniform float texture_width = 640.0;
uniform float texture_height = 360.0;



void fragment(){

	// preračun pravge offseta sence ... pixle konvertamo v texle
	vec2 shadow_offset = vec2(shadow_offset_x / texture_width, shadow_offset_y / texture_height);
	vec2 uvs = SCREEN_UV + shadow_offset * texture_altitude;
	
	// poberemo prikaz texture in apliciramo samo offset še predno apliciramo barvo 
	vec4 color = texture(SCREEN_TEXTURE, uvs);

	
	// manipuliramo izbrano barvo
	if (manipulate_other_colors == false){
		
		// če je barva texture enaka izbrani apliciramo efekt
		if (color == manipulate_color){
			color = shadow_color * color.a;
		}
		// druge barve so brez efekta
		else {
			color.a = 0.0; // 100% transparenca
			color = texture(SCREEN_TEXTURE, SCREEN_UV); // original barva in pozicija
		}
	}
	
	// manipuliramo vse razen izbrane barve
	else if (manipulate_other_colors == true){
		
		// če barva texture ni transparenta apliciramo efekt
		if (color == transparent_color){
//		if (color.a > 0.0){
			
			// barva enaka izbrani barvi je brez efekta
			if (color == manipulate_color){
				color.a = 0.0;
				color = texture(SCREEN_TEXTURE, SCREEN_UV);
			}
			// aplciramo efekt na vse druge barve
			else {
				color = shadow_color * color.a;
			}
		}
		// barva transparentnega dela tekture
		else {
			color = transparent_new_color;
		}
		
	}
	
	COLOR = color;
}"

[sub_resource type="ShaderMaterial" id=63]
shader = SubResource( 61 )
shader_param/manipulate_color = Color( 1, 1, 0, 1 )
shader_param/manipulate_other_colors = false
shader_param/transparent_color = Color( 0, 0, 0, 0 )
shader_param/transparent_new_color = Color( 0, 0, 0, 0 )
shader_param/shadow_color = Color( 0, 0, 0, 0.196078 )
shader_param/shadow_offset_x = 0.0
shader_param/shadow_offset_y = 1.0
shader_param/texture_altitude = 6.0
shader_param/texture_width = 640.0
shader_param/texture_height = 360.0

[sub_resource type="Shader" id=74]
code = "shader_type canvas_item;
render_mode blend_mix;

// šejder v1 - prepoznava 100% transparenco in aplicira novo barvo na te pixle
// šejder v2 - prepoznava tudi cutout barvo, ki jo potem manipulira
// šejder v3 - prepoznava barvo, ki ji mora dodat senco
// šejder v4 - prepoznava različne barve, ki jim dodaj različne sence
// šejder v5 - dodaja sence za prizemljene objekte

//... simple nadgradnja je če dodam več barv za manipulirat ... al pa celo gradient

// barve
uniform vec4 manipulate_color_1 : hint_color = vec4(1.0, 0.0, 0.0, 1.0); // select color to regirster and manipulate
uniform vec4 new_color_1 : hint_color = vec4(1.0, 1.0, 0.0, 1.0); // select color to regirster and manipulate
uniform vec4 manipulate_color_2 : hint_color = vec4(0.0, 1.0, 0.0, 1.0); // select color to regirster and manipulate
uniform vec4 new_color_2 : hint_color = vec4(0.0, 1.0, 1.0, 1.0); // select color to regirster and manipulate
uniform vec4 manipulate_color_3 : hint_color = vec4(0.0, 0.0, 1.0, 1.0); // select color to regirster and manipulate
uniform vec4 new_color_3 : hint_color = vec4(1.0, 0.0, 1.0, 1.0); // select color to regirster and manipulate

uniform bool manipulate_other = false;
uniform vec4 new_color_other : hint_color = vec4(0.5, 0.5, 0.5, 1.0); // select color to regirster and manipulate

uniform vec4 transparent_to_color : hint_color = vec4(0.0, 0.0, 0.0, 0.0); // apply color to texture with alpha 0.0
uniform vec4 transparent_color : hint_color = vec4(0.0, 0.0, 0.0, 0.0); // apply color to texture with alpha 0.0


void fragment(){

	// poberemo prikaz texture in apliciramo samo offset še predno apliciramo barvo 
	vec4 color = texture(SCREEN_TEXTURE, SCREEN_UV);

	
	// manipuliramo izbrane barve
	if (manipulate_other == false){
		
		// če je barva texture enaka izbrani apliciramo novo (s transparenco)
		if (color == manipulate_color_1 ){
			color = new_color_1 * color.a;
		}
		else if (color.rgb == manipulate_color_2.rgb){
			color.rgb = new_color_2.bgr;
			
			float white_level = 0.5; 
			color.rgb = vec3(white_level);
			color.a = white_level
		
		}
		else if (color == manipulate_color_3){
			color = new_color_3 * color.a;
		}
		
		// druge barve so brez efekta
		else {
			color.a = 0.0; // 100% transparenca
//			color = texture(TEXTURE, UV); // original barva in pozicija
		}
	}
	
	// manipuliramo vse druge barve
	else if (manipulate_other == true){
		
		// če barva texture ni transparenta apliciramo efekt
		if (color.a > 0.0){
			
			// barva enaka izbrani barvi je brez efekta
			if (color == manipulate_color_1){
				color.a = 0.0;
			}
			else if (color == manipulate_color_2){
				color.a = 0.0;
			}
			else if (color == manipulate_color_3){
				color.a = 0.0;
			}
			
			// aplciramo prvo barve efekt na vse druge barve
			else {
				color = new_color_other * color.a;
			}
		}
		// barva transparentnega dela tekture
		else {
			color = transparent_to_color;
		}
		
	}
	
	COLOR = color;
}"

[sub_resource type="ShaderMaterial" id=16]
shader = SubResource( 74 )
shader_param/manipulate_color_1 = Color( 1, 1, 0, 1 )
shader_param/new_color_1 = Color( 0, 0, 0.00392157, 1 )
shader_param/manipulate_color_2 = Color( 0, 1, 1, 1 )
shader_param/new_color_2 = Color( 0.898039, 0, 1, 1 )
shader_param/manipulate_color_3 = Color( 0.25098, 0.105882, 0.294118, 0 )
shader_param/new_color_3 = Color( 0.415686, 0.203922, 1, 1 )
shader_param/manipulate_other = false
shader_param/new_color_other = Color( 0.5, 0.5, 0.5, 1 )
shader_param/transparent_to_color = Color( 0, 0, 0, 0 )
shader_param/transparent_color = Color( 0, 0, 0, 0 )

[sub_resource type="TileSet" id=108]
0/name = "new and perfect"
0/texture = ExtResource( 10 )
0/tex_offset = Vector2( 0, 0 )
0/modulate = Color( 1, 1, 1, 1 )
0/region = Rect2( 0, 0, 144, 160 )
0/tile_mode = 1
0/autotile/bitmask_mode = 2
0/autotile/bitmask_flags = [ Vector2( 0, 1 ), 432, Vector2( 0, 2 ), 438, Vector2( 0, 3 ), 54, Vector2( 0, 6 ), 223, Vector2( 0, 7 ), 479, Vector2( 0, 8 ), 475, Vector2( 0, 12 ), 404, Vector2( 0, 13 ), 83, Vector2( 0, 14 ), 213, Vector2( 0, 15 ), 342, Vector2( 0, 16 ), 209, Vector2( 0, 17 ), 86, Vector2( 0, 18 ), 209, Vector2( 0, 19 ), 278, Vector2( 1, 0 ), 315, Vector2( 1, 1 ), 504, Vector2( 1, 2 ), 511, Vector2( 1, 3 ), 63, Vector2( 1, 5 ), 95, Vector2( 1, 9 ), 473, Vector2( 1, 11 ), 123, Vector2( 1, 12 ), 433, Vector2( 1, 13 ), 118, Vector2( 1, 14 ), 405, Vector2( 1, 15 ), 339, Vector2( 1, 16 ), 401, Vector2( 1, 17 ), 275, Vector2( 1, 18 ), 404, Vector2( 1, 19 ), 83, Vector2( 2, 0 ), 246, Vector2( 2, 1 ), 216, Vector2( 2, 2 ), 219, Vector2( 2, 3 ), 27, Vector2( 2, 4 ), 127, Vector2( 2, 6 ), 325, Vector2( 2, 7 ), 501, Vector2( 2, 8 ), 375, Vector2( 2, 10 ), 505, Vector2( 2, 11 ), 183, Vector2( 2, 12 ), 220, Vector2( 2, 13 ), 283, Vector2( 2, 14 ), 212, Vector2( 2, 15 ), 86, Vector2( 2, 16 ), 465, Vector2( 2, 17 ), 279, Vector2( 2, 18 ), 469, Vector2( 2, 19 ), 343, Vector2( 3, 0 ), 441, Vector2( 3, 4 ), 383, Vector2( 3, 7 ), 477, Vector2( 3, 8 ), 351, Vector2( 3, 10 ), 509, Vector2( 3, 11 ), 444, Vector2( 3, 12 ), 401, Vector2( 3, 13 ), 86, Vector2( 3, 14 ), 401, Vector2( 3, 15 ), 275, Vector2( 3, 16 ), 468, Vector2( 3, 17 ), 87, Vector2( 4, 0 ), 222, Vector2( 4, 4 ), 319, Vector2( 4, 7 ), 181, Vector2( 4, 8 ), 370, Vector2( 4, 10 ), 508, Vector2( 4, 11 ), 474, Vector2( 4, 12 ), 212, Vector2( 4, 13 ), 275, Vector2( 4, 14 ), 368, Vector2( 4, 15 ), 53, Vector2( 4, 16 ), 117, Vector2( 4, 17 ), 369, Vector2( 4, 18 ), 373, Vector2( 5, 0 ), 126, Vector2( 5, 5 ), 311, Vector2( 5, 7 ), 157, Vector2( 5, 8 ), 346, Vector2( 5, 9 ), 500, Vector2( 5, 11 ), 318, Vector2( 5, 12 ), 305, Vector2( 5, 13 ), 116, Vector2( 5, 14 ), 344, Vector2( 5, 15 ), 29, Vector2( 5, 16 ), 285, Vector2( 5, 17 ), 348, Vector2( 5, 18 ), 349, Vector2( 6, 0 ), 435, Vector2( 6, 1 ), 144, Vector2( 6, 2 ), 146, Vector2( 6, 3 ), 18, Vector2( 6, 6 ), 439, Vector2( 6, 7 ), 503, Vector2( 6, 8 ), 502, Vector2( 6, 11 ), 498, Vector2( 6, 12 ), 92, Vector2( 6, 13 ), 281, Vector2( 7, 0 ), 252, Vector2( 7, 1 ), 464, Vector2( 7, 2 ), 466, Vector2( 7, 3 ), 23, Vector2( 7, 4 ), 242, Vector2( 7, 5 ), 180, Vector2( 7, 6 ), 306, Vector2( 7, 7 ), 178, Vector2( 7, 8 ), 58, Vector2( 7, 9 ), 184, Vector2( 7, 10 ), 178, Vector2( 7, 11 ), 249, Vector2( 7, 12 ), 497, Vector2( 7, 13 ), 119, Vector2( 8, 0 ), 411, Vector2( 8, 1 ), 400, Vector2( 8, 2 ), 151, Vector2( 8, 3 ), 22, Vector2( 8, 4 ), 314, Vector2( 8, 5 ), 153, Vector2( 8, 6 ), 90, Vector2( 8, 7 ), 184, Vector2( 8, 8 ), 154, Vector2( 8, 9 ), 154, Vector2( 8, 10 ), 58, Vector2( 8, 11 ), 159, Vector2( 8, 12 ), 476, Vector2( 8, 13 ), 287, Vector2( 8, 14 ), 245, Vector2( 8, 15 ), 371, Vector2( 8, 16 ), 241, Vector2( 8, 17 ), 115, Vector2( 9, 0 ), 379, Vector2( 9, 1 ), 208, Vector2( 9, 3 ), 19, Vector2( 9, 4 ), 158, Vector2( 9, 5 ), 240, Vector2( 9, 6 ), 51, Vector2( 9, 7 ), 189, Vector2( 9, 8 ), 243, Vector2( 9, 9 ), 179, Vector2( 9, 10 ), 122, Vector2( 9, 11 ), 314, Vector2( 9, 12 ), 401, Vector2( 9, 13 ), 279, Vector2( 9, 14 ), 413, Vector2( 9, 15 ), 350, Vector2( 9, 16 ), 412, Vector2( 9, 17 ), 286, Vector2( 10, 0 ), 247, Vector2( 10, 1 ), 148, Vector2( 10, 2 ), 82, Vector2( 10, 3 ), 149, Vector2( 10, 4 ), 338, Vector2( 10, 5 ), 408, Vector2( 10, 6 ), 30, Vector2( 10, 7 ), 414, Vector2( 10, 8 ), 378, Vector2( 10, 9 ), 188, Vector2( 10, 10 ), 410, Vector2( 10, 11 ), 242, Vector2( 10, 12 ), 468, Vector2( 10, 13 ), 87, Vector2( 10, 14 ), 177, Vector2( 10, 15 ), 114, Vector2( 10, 16 ), 496, Vector2( 10, 17 ), 55, Vector2( 11, 0 ), 445, Vector2( 11, 1 ), 145, Vector2( 11, 2 ), 274, Vector2( 11, 3 ), 404, Vector2( 11, 4 ), 83, Vector2( 11, 5 ), 176, Vector2( 11, 6 ), 50, Vector2( 11, 7 ), 182, Vector2( 11, 8 ), 59, Vector2( 11, 9 ), 248, Vector2( 11, 10 ), 434, Vector2( 11, 11 ), 441, Vector2( 11, 12 ), 309, Vector2( 11, 13 ), 372, Vector2( 11, 14 ), 156, Vector2( 11, 15 ), 282, Vector2( 11, 16 ), 472, Vector2( 11, 17 ), 31, Vector2( 12, 0 ), 478, Vector2( 12, 1 ), 48, Vector2( 12, 2 ), 308, Vector2( 12, 3 ), 304, Vector2( 12, 4 ), 52, Vector2( 12, 5 ), 152, Vector2( 12, 6 ), 26, Vector2( 12, 7 ), 440, Vector2( 12, 8 ), 218, Vector2( 12, 9 ), 155, Vector2( 12, 10 ), 62, Vector2( 12, 11 ), 158, Vector2( 12, 12 ), 345, Vector2( 12, 13 ), 93, Vector2( 12, 14 ), 21, Vector2( 12, 15 ), 336, Vector2( 12, 16 ), 277, Vector2( 12, 17 ), 337, Vector2( 13, 0 ), 382, Vector2( 13, 1 ), 56, Vector2( 13, 2 ), 121, Vector2( 13, 3 ), 316, Vector2( 13, 5 ), 244, Vector2( 13, 6 ), 307, Vector2( 13, 7 ), 436, Vector2( 13, 8 ), 310, Vector2( 13, 10 ), 61, Vector2( 13, 11 ), 376, Vector2( 13, 12 ), 437, Vector2( 13, 13 ), 374, Vector2( 13, 14 ), 81, Vector2( 13, 15 ), 276, Vector2( 13, 16 ), 85, Vector2( 13, 17 ), 340, Vector2( 14, 0 ), 499, Vector2( 14, 1 ), 24, Vector2( 14, 2 ), 89, Vector2( 14, 3 ), 88, Vector2( 14, 4 ), 25, Vector2( 14, 5 ), 409, Vector2( 14, 6 ), 94, Vector2( 14, 7 ), 217, Vector2( 14, 8 ), 91, Vector2( 14, 10 ), 211, Vector2( 14, 11 ), 406, Vector2( 14, 12 ), 221, Vector2( 14, 13 ), 347, Vector2( 14, 14 ), 273, Vector2( 14, 15 ), 84, Vector2( 15, 0 ), 253, Vector2( 15, 1 ), 112, Vector2( 15, 2 ), 49, Vector2( 15, 3 ), 113, Vector2( 15, 4 ), 116, Vector2( 15, 5 ), 381, Vector2( 15, 6 ), 313, Vector2( 15, 7 ), 124, Vector2( 15, 8 ), 57, Vector2( 15, 9 ), 120, Vector2( 15, 10 ), 60, Vector2( 15, 11 ), 312, Vector2( 15, 12 ), 212, Vector2( 15, 13 ), 86, Vector2( 15, 14 ), 341, Vector2( 16, 0 ), 415, Vector2( 16, 1 ), 28, Vector2( 16, 2 ), 280, Vector2( 16, 3 ), 284, Vector2( 16, 4 ), 92, Vector2( 16, 5 ), 471, Vector2( 16, 6 ), 214, Vector2( 16, 7 ), 403, Vector2( 16, 8 ), 210, Vector2( 16, 9 ), 402, Vector2( 16, 10 ), 147, Vector2( 16, 11 ), 150, Vector2( 16, 12 ), 305, Vector2( 16, 13 ), 116, Vector2( 16, 14 ), 17, Vector2( 16, 15 ), 80, Vector2( 17, 0 ), 185, Vector2( 17, 1 ), 16, Vector2( 17, 3 ), 186, Vector2( 17, 4 ), 470, Vector2( 17, 5 ), 467, Vector2( 17, 6 ), 407, Vector2( 17, 7 ), 215, Vector2( 17, 8 ), 317, Vector2( 17, 9 ), 380, Vector2( 17, 10 ), 377, Vector2( 17, 11 ), 125, Vector2( 17, 12 ), 281, Vector2( 17, 13 ), 92, Vector2( 17, 14 ), 20, Vector2( 17, 15 ), 272 ]
0/autotile/icon_coordinate = Vector2( 1, 2 )
0/autotile/tile_size = Vector2( 8, 8 )
0/autotile/spacing = 0
0/autotile/occluder_map = [  ]
0/autotile/navpoly_map = [  ]
0/autotile/priority_map = [  ]
0/autotile/z_index_map = [  ]
0/occluder_offset = Vector2( 0, 0 )
0/navigation_offset = Vector2( 0, 0 )
0/shape_offset = Vector2( 0, 0 )
0/shape_transform = Transform2D( 1, 0, 0, 1, 0, 0 )
0/shape_one_way = false
0/shape_one_way_margin = 0.0
0/shapes = [  ]
0/z_index = 0

[sub_resource type="Shader" id=82]
code = "shader_type canvas_item;

// šejder v1 - prepoznava 100% transparenco in aplicira novo barvo na te pixle
// šejder v2 - prepoznava tudi cutout barvo, ki jo potem manipulira
// šejder v3 - prepoznava barvo, ki ji mora dodat senco
// šejder v4 - prepoznava različne barve, ki jim dodaj različne sence
// šejder v5 - dodaja sence za prizemljene objekte

//... simple nadgradnja je če dodam več barv za manipulirat ... al pa celo gradient

// barve
uniform vec4 manipulate_color : hint_color = vec4(1.0, 0.0, 0.0, 1.0); // select color to regirster and manipulate
uniform vec4 manipulate_high_color : hint_color = vec4(1.0, 1.0, 1.0, 1.0); // select color to regirster and manipulate
uniform bool manipulate_other_colors = true;
uniform vec4 transparent_color : hint_color = vec4(0.0, 0.0, 0.0, 0.0); // apply color to texture with alpha 0.0
uniform vec4 transparent_new_color : hint_color = vec4(0.0, 0.0, 0.0, 0.0); // apply color to texture with alpha 0.0

// shadow
uniform vec4 shadow_color : hint_color = vec4(0.0, 0.0, 0.0, 1.0);
uniform float shadow_offset_x = 1.0; // smer offseta ... to niso texli ampak pixli
uniform float shadow_offset_y = 1.0; // smer offseta ... to niso texli ampak pixli
uniform float texture_altitude = 5.0; // količina offseta ... višin texture

// dimenzija teksture za uskladitev texlov s pixli (1/texture original size)  
uniform float texture_width = 640.0;
uniform float texture_height = 360.0;



void fragment(){

	// preračun pravge offseta sence ... pixle konvertamo v texle
	vec2 shadow_offset = vec2(shadow_offset_x / texture_width, shadow_offset_y / texture_height);
	vec2 uvs = SCREEN_UV + shadow_offset * texture_altitude;
	
	// poberemo prikaz texture in apliciramo samo offset še predno apliciramo barvo 
	vec4 color = texture(SCREEN_TEXTURE, uvs);

	
	// manipuliramo izbrano barvo
	if (manipulate_other_colors == false){
		
		// če je barva texture enaka izbrani apliciramo efekt
		if (color == manipulate_color){
			color = shadow_color * color.a;
		}
		else if (color == manipulate_high_color){
			color = vec4(1.0, 1.0, 1.0, 1.0) ;
			
		}
		// druge barve so brez efekta
		else {
			color.a = 0.0; // 100% transparenca
			color = texture(SCREEN_TEXTURE, SCREEN_UV); // original barva in pozicija
		}
	}
	
	// manipuliramo vse razen izbrane barve
	else if (manipulate_other_colors == true){
		
		// če barva texture ni transparenta apliciramo efekt
		if (color == transparent_color){
//		if (color.a > 0.0){
			
			// barva enaka izbrani barvi je brez efekta
			if (color == manipulate_color){
				color.a = 0.0;
				color = texture(SCREEN_TEXTURE, SCREEN_UV);
			}
			// aplciramo efekt na vse druge barve
			else {
				color = shadow_color * color.a;
			}
		}
		// barva transparentnega dela tekture
		else {
			color = transparent_new_color;
		}
		
	}
	
	COLOR = color;
}"

[sub_resource type="ShaderMaterial" id=83]
shader = SubResource( 82 )
shader_param/manipulate_color = Color( 0, 0, 0, 1 )
shader_param/manipulate_high_color = Color( 0.537255, 0.309804, 1, 1 )
shader_param/manipulate_other_colors = false
shader_param/transparent_color = Color( 0, 0, 0, 0 )
shader_param/transparent_new_color = Color( 0, 0, 0, 0.27451 )
shader_param/shadow_color = Color( 0, 0, 0, 0.196078 )
shader_param/shadow_offset_x = 0.0
shader_param/shadow_offset_y = 1.0
shader_param/texture_altitude = 12.0
shader_param/texture_width = 640.0
shader_param/texture_height = 360.0

[sub_resource type="Shader" id=64]
code = "shader_type canvas_item;

// šejder v1 - prepoznava 100% transparenco in aplicira novo barvo na te pixle
// šejder v2 - prepoznava tudi cutout barvo, ki jo potem manipulira
// šejder v3 - prepoznava barvo, ki ji mora dodat senco
// šejder v4 - prepoznava različne barve, ki jim dodaj različne sence
// šejder v5 - dodaja sence za prizemljene objekte

//... simple nadgradnja je če dodam več barv za manipulirat ... al pa celo gradient

// barve
uniform vec4 manipulate_color_1 : hint_color = vec4(1.0, 0.0, 0.0, 1.0); // select color to regirster and manipulate
uniform vec4 new_color_1 : hint_color = vec4(1.0, 1.0, 0.0, 1.0); // select color to regirster and manipulate
uniform vec4 manipulate_color_2 : hint_color = vec4(0.0, 1.0, 0.0, 1.0); // select color to regirster and manipulate
uniform vec4 new_color_2 : hint_color = vec4(0.0, 1.0, 1.0, 1.0); // select color to regirster and manipulate
uniform vec4 manipulate_color_3 : hint_color = vec4(0.0, 0.0, 1.0, 1.0); // select color to regirster and manipulate
uniform vec4 new_color_3 : hint_color = vec4(1.0, 0.0, 1.0, 1.0); // select color to regirster and manipulate

uniform bool manipulate_other = false;
uniform vec4 new_color_other : hint_color = vec4(0.5, 0.5, 0.5, 1.0); // select color to regirster and manipulate

uniform vec4 transparent_to_color : hint_color = vec4(0.0, 0.0, 0.0, 0.0); // apply color to texture with alpha 0.0


void fragment(){

	// poberemo prikaz texture in apliciramo samo offset še predno apliciramo barvo 
	vec4 color = texture(SCREEN_TEXTURE, SCREEN_UV);

	
	// manipuliramo izbrane barve
	if (manipulate_other == false){
		
		// če je barva texture enaka izbrani apliciramo novo (s transparenco)
		if (color == manipulate_color_1 ){
			color = new_color_1 * color.a;
		}
		else if (color == manipulate_color_2){
			color = new_color_2 * color.a;
		}
		else if (color == manipulate_color_3){
			color = new_color_3 * color.a;
		}
		
		// druge barve so brez efekta
		else {
			color.a = 0.0; // 100% transparenca
//			color = texture(TEXTURE, UV); // original barva in pozicija
		}
	}
	
	// manipuliramo vse druge barve
	else if (manipulate_other == true){
		
		// če barva texture ni transparenta apliciramo efekt
		if (color.a > 0.0){
			
			// barva enaka izbrani barvi je brez efekta
			if (color == manipulate_color_1){
				color.a = 0.0;
			}
			else if (color == manipulate_color_2){
				color.a = 0.0;
			}
			else if (color == manipulate_color_3){
				color.a = 0.0;
			}
			
			// aplciramo prvo barve efekt na vse druge barve
			else {
				color = new_color_other * color.a;
			}
		}
		// barva transparentnega dela tekture
		else {
			color = transparent_to_color;
		}
		
	}
	
	COLOR = color;
}"

[sub_resource type="ShaderMaterial" id=65]
shader = SubResource( 64 )
shader_param/manipulate_color_1 = Color( 0, 1, 0, 1 )
shader_param/new_color_1 = Color( 1, 1, 0.675781, 1 )
shader_param/manipulate_color_2 = Color( 0, 0, 0, 1 )
shader_param/new_color_2 = Color( 0, 0, 0.00392157, 1 )
shader_param/manipulate_color_3 = Color( 1, 1, 1, 0 )
shader_param/new_color_3 = Color( 0.415686, 0.203922, 1, 1 )
shader_param/manipulate_other = false
shader_param/new_color_other = Color( 0.5, 0.5, 0.5, 1 )
shader_param/transparent_to_color = Color( 0, 0, 0, 0 )

[sub_resource type="Shader" id=98]
code = "shader_type canvas_item;

// Donut Mask
uniform vec2 DonutMaskCenter = vec2(0.5);
uniform float DonutMaskSize = 0.5;
uniform float DonutMaskThickness = 0.15;

// Outline
uniform float OutlineWidth : hint_range(0.0, 64) = 3.0;
uniform float OutlinePixelSize : hint_range(0.01, 10.0) = 1;

// Rainbow
uniform bool UseRainbowColorOutline = true;
uniform float RainbowColorLightOffset : hint_range(0.0, 1.0) = 0.5;   // this offsets all color channels; if set to 0 only red green and blue colors will be shown.
uniform float RainbowColorSinFrequency : hint_range(0.1, 2.0) = 0.1;  // frequency of the rainbow

// Noise
uniform bool OutlineUseNoise = false;
uniform float NoiseBlockSize = 5.0;
uniform float NoiseMaxLineWidth = 10.0;
uniform float NoiseMinLineWidth = 5.0;
uniform float NoiseFreq = 1.0;

uniform vec4 BackgroundColor : hint_color = vec4(0.95, 0.95, 0.95, 1.0);

// Noise Constants
const float PI = 3.1415;
const int ANGLE_RESOLUTION = 16;
const int GRADIENT_RESOLUTION = 8;

// Mmmm donuts
float createDonutMask(
	vec2 inputTexturePixelSize,
	vec2 inputUV) {
	float ratio = inputTexturePixelSize.x / inputTexturePixelSize.y;
	vec2 scaledUV = (inputUV - vec2(DonutMaskCenter.x, 0.0)) / vec2(ratio, 1.0) + vec2(DonutMaskCenter.x, 0.0);
	return (1.0 - smoothstep(DonutMaskSize - 0.2, DonutMaskSize, length(scaledUV - DonutMaskCenter))) *
		smoothstep(DonutMaskSize - DonutMaskThickness - 0.1, 
		DonutMaskSize - DonutMaskThickness, length(scaledUV - DonutMaskCenter)
	);
}

vec4 createRainbowColor(float t) {
	return vec4(RainbowColorLightOffset + sin(2.0*3.14*RainbowColorSinFrequency*t),
							   RainbowColorLightOffset + sin(2.0*3.14*RainbowColorSinFrequency*t + radians(120.0)),
							   RainbowColorLightOffset + sin(2.0*3.14*RainbowColorSinFrequency*t + radians(240.0)),
							   1.0);
}

vec4 handleInline(vec4 finalPixelColor, vec4 outlineColor, vec4 originalPixelColor) {
	// Handle inline
    if (finalPixelColor.r < BackgroundColor.r || finalPixelColor.g < BackgroundColor.g || finalPixelColor.b < BackgroundColor.b) {
        finalPixelColor.rgb = mix(outlineColor.rgb, finalPixelColor.rgb, 1.0 - tanh(3.0*originalPixelColor.b));
    }
	
	return finalPixelColor;
}

float hash(vec2 p, float s) {
	return fract(35.1 * sin(dot(vec3(112.3, 459.2, 753.2), vec3(p, s))));
}

float noise(vec2 p, float s) {
	vec2 d = vec2(0, 1);
	vec2 b = floor(p);
	vec2 f = fract(p);
	return mix(
		mix(hash(b + d.xx, s), hash(b + d.yx, s), f.x),
		mix(hash(b + d.xy, s), hash(b + d.yy, s), f.x), f.y);
}

float getLineWidth(vec2 p, float s) {
	p /= NoiseBlockSize;
	float w = 0.0;
	float intensity = 1.0;
	for (int i = 0; i < 3; i++) {
		w = mix(w, noise(p, s), intensity);
		p /= 2.0;
		intensity /= 2.0;
	}
	
	return mix(NoiseMaxLineWidth, NoiseMinLineWidth, w);
}

bool pixelInRange(sampler2D text, vec2 uv, vec2 dist) {
	float alpha = 0.0;
	for (int i = 0; i < ANGLE_RESOLUTION; i++) {
		float angle = 2.0 * PI * float(i) / float(ANGLE_RESOLUTION);
		vec2 disp = dist * vec2(cos(angle), sin(angle));
		if (texture(text, uv + disp).b < 0.5) return true;
	}
	return false;
}

float getClosestDistance(sampler2D text, vec2 uv, vec2 maxDist) {
	if (!pixelInRange(text, uv, maxDist)) return -1.0;
	
	float hi = 1.0; float lo = 0.0;
	
	for (int i = 1; i <= GRADIENT_RESOLUTION; i++) {
		float curr = (hi + lo) / 2.0;
		if (pixelInRange(text, uv, curr * maxDist)) {
			hi = curr;
		}
		else {
			lo = curr;
		}
	}
	return hi;
	
}

vec4 handleNoise(
	vec4 finalPixelColor, 
	float t,  
	vec2 pixelSize,
	sampler2D inputTexture,
	vec2 inputUV,
	vec4 originalPixelColor) {
		
	float timeStep = floor(NoiseFreq * t);
	vec2 scaledDistance = pixelSize * getLineWidth(inputUV / pixelSize, timeStep);
	float weight = getClosestDistance(inputTexture, inputUV, scaledDistance);
	
	if ( weight > 0.0) {
	    finalPixelColor.a = mix(0.0, finalPixelColor.a, tanh(5.0*weight));
	} else {
		finalPixelColor = originalPixelColor;
	}
	
	return finalPixelColor;
}

vec4 handleOutline(vec4 finalPixelColor, 
					vec4 outlineColor, 
					vec4 originalPixelColor, 
					sampler2D inputTexture, 
					vec2 inputUV) {
	if (finalPixelColor.r > 0.05 || finalPixelColor.g > 0.05 || finalPixelColor.b > 0.05) {
		vec2 unit = (OutlinePixelSize ) / vec2(textureSize(inputTexture, 0));
		
        finalPixelColor.rgb = mix(outlineColor.rgb, finalPixelColor.rgb, 1.0 - tanh(3.0*originalPixelColor.b));
		finalPixelColor.a = 0.0;

        for (float x = -ceil(OutlineWidth); x <= ceil(OutlineWidth); x++) {
            for (float y = -ceil(OutlineWidth); y <= ceil(OutlineWidth); y++) {
				vec4 current_texture = texture(inputTexture, inputUV + vec2(x*unit.x, y*unit.y));
                if (current_texture.r > 0.5 || current_texture.g > 0.5 || current_texture.b > 0.5 || (x==0.0 && y==0.0)) {
                    continue;
                }
                finalPixelColor.a += outlineColor.a / (pow(x,2)+pow(y,2)) * (1.0-pow(2.0, -OutlineWidth));
				if (finalPixelColor.a > 1.0) {
					finalPixelColor.a = 1.0;
				}
            }
        }
    }
	
	return finalPixelColor;
}

void fragment() {
	float mask = createDonutMask(
		TEXTURE_PIXEL_SIZE,
		UV);
		
	vec4 outlineColor = vec4(1.0, 0.0, 0.0, 1.0);
	if (UseRainbowColorOutline){
		outlineColor = createRainbowColor(TIME);
	}
	
	vec4 finalPixelColor = texture(SCREEN_TEXTURE, SCREEN_UV);
	vec4 originalPixelColor = finalPixelColor;
	
	finalPixelColor = handleInline(finalPixelColor, outlineColor, originalPixelColor);
	finalPixelColor = handleOutline(finalPixelColor, 
		outlineColor,
		originalPixelColor,
		SCREEN_TEXTURE, 
		SCREEN_UV);
	
	finalPixelColor.a = finalPixelColor.a * mask;
	
	if (OutlineUseNoise) {
		finalPixelColor = handleNoise(
			finalPixelColor, 
			TIME,  
			SCREEN_PIXEL_SIZE,
			SCREEN_TEXTURE,
			SCREEN_UV,
			originalPixelColor);
	}
	
	COLOR = finalPixelColor;
}"

[sub_resource type="ShaderMaterial" id=99]
shader = SubResource( 98 )
shader_param/DonutMaskCenter = Vector2( 0.5, 0.5 )
shader_param/DonutMaskSize = 0.458
shader_param/DonutMaskThickness = 1.0
shader_param/OutlineWidth = 1.0
shader_param/OutlinePixelSize = 0.01
shader_param/UseRainbowColorOutline = true
shader_param/RainbowColorLightOffset = 0.5
shader_param/RainbowColorSinFrequency = 0.1
shader_param/OutlineUseNoise = false
shader_param/NoiseBlockSize = 5.0
shader_param/NoiseMaxLineWidth = 10.0
shader_param/NoiseMinLineWidth = 5.0
shader_param/NoiseFreq = 1.0
shader_param/BackgroundColor = Color( 0.054902, 0.713726, 0.435294, 1 )

[sub_resource type="Shader" id=4]
code = "shader_type canvas_item;

uniform float intensity = 0.5f;
uniform float layers = 5.0f;
uniform float speed = 4.0f;

float gradient(vec2 uv){
	
	// čekiramo razdaljo od centra sprajta do koordinate trenutne pike
	return (0.5f - distance(vec2(uv.x, uv.y), vec2(0.5f, 0.5f))); // nastane krog, ker je razdalja od centra konstantna
	
	
}
void fragment(){
	vec4 bg = texture(TEXTURE, UV - TIME/speed); // tukjaj je že notri premikanje
	
	COLOR = bg;
	COLOR.r = gradient(UV); // red kanal damo rezultat gradient funkcije 
	
	// množimo oz. združimo red channel z intensity in teksturo noisa
	COLOR.r = clamp(COLOR.r * bg.r * intensity * 10.0f, 0.0f, 1.0f); // klempam, da ne gre pod nulo in ne nad ena (ker je to barvni kanal)
	//	current color * intensity
	
	
	
	
}"

[sub_resource type="ShaderMaterial" id=2]
shader = SubResource( 4 )
shader_param/intensity = 0.5
shader_param/layers = 5.0
shader_param/speed = 4.0

[sub_resource type="OpenSimplexNoise" id=100]
period = 20.0

[sub_resource type="NoiseTexture" id=3]
width = 48
height = 48
seamless = true
noise = SubResource( 100 )

[sub_resource type="Shader" id=11]
code = "shader_type canvas_item;
render_mode blend_mix ;

uniform float intensity = 0.5f;
uniform float layers = 5.0f;
uniform float speed = 4.0f;

float gradient(vec2 uv){
	
	// čekiramo razdaljo od centra sprajta do koordinate trenutne pike
	return (0.5f - distance(vec2(uv.x, uv.y), vec2(0.5f, 0.5f))); // nastane krog, ker je razdalja od centra konstantna
}

vec4 colorize (float col, float a) {
	
	vec4 pallete;
	
//	// grayscale
//	pallete = vec4(col, col, col, a);  // col je podan red kanal

//	// monochrome
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.g = float(col >= 0.0f); // en kanal setamo, da je ves čas 0, razen ko je poln (? ... full je white?)
	
//	// darken vse kar ni belo
	pallete = vec4(col, col, col, a);  // col je podan red kanal
	pallete.r = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
	pallete.g = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
	pallete.b = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
	
//	// raznobarvno
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = float(col > 0.3 && col < 0.7 || col > 0.9); 
//	pallete.g = float(col > 0.7); // višja vrednost od dveh ...?
//	pallete.b = float(col > 0.5 || col > 0.9); // višja vrednost od dveh ...?
	
//	// ta bi bila za ščit
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.g = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.b = float(col > 0.3); // višja vrednost od dveh ...?
	
	return pallete; // ta vrednost gre v barvo
}


void fragment(){
	vec4 bg = texture(TEXTURE, UV - TIME/speed); // tukjaj je že notri premikanje
	
	COLOR = bg;
	COLOR.r = gradient(UV); // red kanal damo rezultat gradient funkcije 
	
	// množimo oz. združimo red channel z intensity in teksturo noisa
	COLOR.r = clamp(COLOR.r * bg.r * intensity * 10.0f, 0.0f, 1.0f); // klempam, da ne gre pod nulo in ne nad ena (ker je to barvni kanal)
	//	current color * intensity
	COLOR.r = floor(COLOR.r * layers) / layers; // floor ... zaokrožimo zato, ker ker je št. lejerja zmeraj cela številka ... delimo z lejerji, da je vsak lejer na 0.2 vrednosti
	COLOR.a = float(COLOR.r > 0.0f); // ?
	
	COLOR = colorize(COLOR.r, COLOR.a); // igranje z barvami
	
	
}"

[sub_resource type="ShaderMaterial" id=101]
shader = SubResource( 11 )
shader_param/intensity = 1.0
shader_param/layers = 4.0
shader_param/speed = 4.0

[sub_resource type="OpenSimplexNoise" id=25]
period = 20.0

[sub_resource type="NoiseTexture" id=102]
width = 48
height = 48
seamless = true
noise = SubResource( 25 )

[sub_resource type="Shader" id=103]
code = "shader_type canvas_item;
render_mode blend_mix ;

uniform float intensity = 0.5f;
uniform float layers = 5.0f;
uniform float speed = 4.0f;

float gradient(vec2 uv){
	
	// čekiramo razdaljo od centra sprajta do koordinate trenutne pike
	return (0.5f - distance(vec2(uv.x, uv.y), vec2(0.5f, 0.5f))); // nastane krog, ker je razdalja od centra konstantna
}

vec4 colorize (float col, float a) {
	
	vec4 pallete;
	
//	// grayscale
//	pallete = vec4(col, col, col, a);  // col je podan red kanal

//	// monochrome
	pallete = vec4(col, col, col, a);  // col je podan red kanal
	pallete.g = float(col >= 0.0f); // en kanal setamo, da je ves čas 0, razen ko je poln (? ... full je white?)
	
//	// darken vse kar ni belo
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.g = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.b = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
	
//	// raznobarvno
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = float(col > 0.3 && col < 0.7 || col > 0.9); 
//	pallete.g = float(col > 0.7); // višja vrednost od dveh ...?
//	pallete.b = float(col > 0.5 || col > 0.9); // višja vrednost od dveh ...?
	
//	// ta bi bila za ščit
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.g = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.b = float(col > 0.3); // višja vrednost od dveh ...?
	
	return pallete; // ta vrednost gre v barvo
}


void fragment(){
	vec4 bg = texture(TEXTURE, UV - TIME/speed); // tukjaj je že notri premikanje
	
	COLOR = bg;
	COLOR.r = gradient(UV); // red kanal damo rezultat gradient funkcije 
	
	// množimo oz. združimo red channel z intensity in teksturo noisa
	COLOR.r = clamp(COLOR.r * bg.r * intensity * 10.0f, 0.0f, 1.0f); // klempam, da ne gre pod nulo in ne nad ena (ker je to barvni kanal)
	//	current color * intensity
	COLOR.r = floor(COLOR.r * layers) / layers; // floor ... zaokrožimo zato, ker ker je št. lejerja zmeraj cela številka ... delimo z lejerji, da je vsak lejer na 0.2 vrednosti
	COLOR.a = float(COLOR.r > 0.0f); // ?
	
	COLOR = colorize(COLOR.r, COLOR.a); // igranje z barvami
	
	
}"

[sub_resource type="ShaderMaterial" id=104]
shader = SubResource( 103 )
shader_param/intensity = 1.0
shader_param/layers = 4.0
shader_param/speed = 4.0

[sub_resource type="Shader" id=12]
code = "shader_type canvas_item;
render_mode blend_mix ;

uniform float intensity = 0.5f;
uniform float layers = 5.0f;
uniform float speed = 4.0f;

float gradient(vec2 uv){
	
	// čekiramo razdaljo od centra sprajta do koordinate trenutne pike
	return (0.5f - distance(vec2(uv.x, uv.y), vec2(0.5f, 0.5f))); // nastane krog, ker je razdalja od centra konstantna
}

vec4 colorize (float col, float a) {
	
	vec4 pallete;
	
//	// grayscale
	pallete = vec4(col, col, col, a);  // col je podan red kanal

//	// monochrome
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.g = float(col >= 0.0f); // en kanal setamo, da je ves čas 0, razen ko je poln (? ... full je white?)
	
//	// darken vse kar ni belo
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.g = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.b = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
	
//	// raznobarvno
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = float(col > 0.3 && col < 0.7 || col > 0.9); 
//	pallete.g = float(col > 0.7); // višja vrednost od dveh ...?
//	pallete.b = float(col > 0.5 || col > 0.9); // višja vrednost od dveh ...?
	
//	// ta bi bila za ščit
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.g = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.b = float(col > 0.3); // višja vrednost od dveh ...?
	
	return pallete; // ta vrednost gre v barvo
}


void fragment(){
	vec4 bg = texture(TEXTURE, UV - TIME/speed); // tukjaj je že notri premikanje
	
	COLOR = bg;
	COLOR.r = gradient(UV); // red kanal damo rezultat gradient funkcije 
	
	// množimo oz. združimo red channel z intensity in teksturo noisa
	COLOR.r = clamp(COLOR.r * bg.r * intensity * 10.0f, 0.0f, 1.0f); // klempam, da ne gre pod nulo in ne nad ena (ker je to barvni kanal)
	//	current color * intensity
	COLOR.r = floor(COLOR.r * layers) / layers; // floor ... zaokrožimo zato, ker ker je št. lejerja zmeraj cela številka ... delimo z lejerji, da je vsak lejer na 0.2 vrednosti
	COLOR.a = float(COLOR.r > 0.0f); // ?
	
	COLOR = colorize(COLOR.r, COLOR.a); // igranje z barvami
	
	
}"

[sub_resource type="ShaderMaterial" id=105]
shader = SubResource( 12 )
shader_param/intensity = 1.0
shader_param/layers = 4.0
shader_param/speed = 4.0

[sub_resource type="Shader" id=26]
code = "shader_type canvas_item;
render_mode blend_mix ;

uniform float intensity = 0.5f;
uniform float layers = 5.0f;
uniform float speed = 4.0f;

float gradient(vec2 uv){
	
	// čekiramo razdaljo od centra sprajta do koordinate trenutne pike
	return (0.5f - distance(vec2(uv.x, uv.y), vec2(0.5f, 0.5f))); // nastane krog, ker je razdalja od centra konstantna
}

vec4 colorize (float col, float a) {
	
	vec4 pallete;
	
//	// grayscale
//	pallete = vec4(col, col, col, a);  // col je podan red kanal

//	// monochrome
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.g = float(col >= 0.0f); // en kanal setamo, da je ves čas 0, razen ko je poln (? ... full je white?)
	
//	// darken vse kar ni belo
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.g = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.b = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
	
//	// raznobarvno
	pallete = vec4(col, col, col, a);  // col je podan red kanal
	pallete.r = float(col > 0.3 && col < 0.7 || col > 0.9); 
	pallete.g = float(col > 0.7); // višja vrednost od dveh ...?
	pallete.b = float(col > 0.5 || col > 0.9); // višja vrednost od dveh ...?
	
//	// ta bi bila za ščit
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.g = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.b = float(col > 0.3); // višja vrednost od dveh ...?
	
	return pallete; // ta vrednost gre v barvo
}


void fragment(){
	vec4 bg = texture(TEXTURE, UV - TIME/speed); // tukjaj je že notri premikanje
	
	COLOR = bg;
	COLOR.r = gradient(UV); // red kanal damo rezultat gradient funkcije 
	
	// množimo oz. združimo red channel z intensity in teksturo noisa
	COLOR.r = clamp(COLOR.r * bg.r * intensity * 10.0f, 0.0f, 1.0f); // klempam, da ne gre pod nulo in ne nad ena (ker je to barvni kanal)
	//	current color * intensity
	COLOR.r = floor(COLOR.r * layers) / layers; // floor ... zaokrožimo zato, ker ker je št. lejerja zmeraj cela številka ... delimo z lejerji, da je vsak lejer na 0.2 vrednosti
	COLOR.a = float(COLOR.r > 0.0f); // ?
	
	COLOR = colorize(COLOR.r, COLOR.a); // igranje z barvami
	
	
}"

[sub_resource type="ShaderMaterial" id=106]
shader = SubResource( 26 )
shader_param/intensity = 1.0
shader_param/layers = 4.0
shader_param/speed = 4.0

[sub_resource type="Shader" id=17]
code = "shader_type canvas_item;
render_mode blend_mix ;

uniform float intensity = 0.5f;
uniform float layers = 5.0f;
uniform float speed = 4.0f;

float gradient(vec2 uv){
	
	// čekiramo razdaljo od centra sprajta do koordinate trenutne pike
	return (0.5f - distance(vec2(uv.x, uv.y), vec2(0.5f, 0.5f))); // nastane krog, ker je razdalja od centra konstantna
}

vec4 colorize (float col, float a) {
	
	vec4 pallete;
	
//	// grayscale
//	pallete = vec4(col, col, col, a);  // col je podan red kanal

//	// monochrome
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.g = float(col >= 0.0f); // en kanal setamo, da je ves čas 0, razen ko je poln (? ... full je white?)
	
//	// darken vse kar ni belo
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.g = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.b = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
	
//	// raznobarvno
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = float(col > 0.3 && col < 0.7 || col > 0.9); 
//	pallete.g = float(col > 0.7); // višja vrednost od dveh ...?
//	pallete.b = float(col > 0.5 || col > 0.9); // višja vrednost od dveh ...?
	
//	// ta bi bila za ščit
	pallete = vec4(col, col, col, a);  // col je podan red kanal
	pallete.r = float(col > 0.3); // višja vrednost od dveh ...?
	pallete.g = float(col > 0.3); // višja vrednost od dveh ...?
	pallete.b = float(col > 0.3); // višja vrednost od dveh ...?
	
	return pallete; // ta vrednost gre v barvo
}


void fragment(){
	vec4 bg = texture(TEXTURE, UV - TIME/speed); // tukjaj je že notri premikanje
	
	COLOR = bg;
	COLOR.r = gradient(UV); // red kanal damo rezultat gradient funkcije 
	
	// množimo oz. združimo red channel z intensity in teksturo noisa
	COLOR.r = clamp(COLOR.r * bg.r * intensity * 10.0f, 0.0f, 1.0f); // klempam, da ne gre pod nulo in ne nad ena (ker je to barvni kanal)
	//	current color * intensity
	COLOR.r = floor(COLOR.r * layers) / layers; // floor ... zaokrožimo zato, ker ker je št. lejerja zmeraj cela številka ... delimo z lejerji, da je vsak lejer na 0.2 vrednosti
	COLOR.a = float(COLOR.r > 0.0f); // ?
	
	COLOR = colorize(COLOR.r, COLOR.a); // igranje z barvami
	
	
}"

[sub_resource type="ShaderMaterial" id=18]
shader = SubResource( 17 )
shader_param/intensity = 1.0
shader_param/layers = 4.0
shader_param/speed = 4.0

[sub_resource type="Shader" id=21]
code = "shader_type canvas_item;
render_mode blend_mix ;

uniform float intensity = 0.5f;
uniform float layers = 5.0f;
uniform float speed = 4.0f;

float gradient(vec2 uv){
	
	// čekiramo razdaljo od centra sprajta do koordinate trenutne pike
//	return (0.5f - distance(vec2(uv.x, uv.y), vec2(0.5f, 0.5f))); // nastane krog, ker je razdalja od centra konstantna
	return (0.5f - distance(vec2(0.0f, uv.y), vec2(0.0f, 0.5f))); // gradient from top to bottom, focus middle
//	return (1.0f - distance(vec2(0.0f, uv.y), vec2(0.0f, 0.0f))); // gradient from top
//	return (1.0f - distance(vec2(0.0f, uv.y), vec2(0.0f, 0.0f))); // gradient from bottom
}

vec4 colorize (float col, float a) {
	
	vec4 pallete;
	
//	// grayscale
//	pallete = vec4(col, col, col, a);  // col je podan red kanal

//	// monochrome
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.g = float(col >= 0.0f); // en kanal setamo, da je ves čas 0, razen ko je poln (? ... full je white?)
	
//	// darken vse kar ni belo
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.g = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.b = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
	
//	// raznobarvno
	pallete = vec4(col, col, col, a);  // col je podan red kanal
	pallete.r = float(col > 0.3 && col < 0.7 || col > 0.9); 
	pallete.g = float(col > 0.7); // višja vrednost od dveh ...?
	pallete.b = float(col > 0.5 || col > 0.9); // višja vrednost od dveh ...?
	
//	// ta bi bila za ščit
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.g = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.b = float(col > 0.3); // višja vrednost od dveh ...?
	
	return pallete; // ta vrednost gre v barvo
}


void fragment(){
	vec4 bg = texture(TEXTURE, UV - TIME/speed); // tukjaj je že notri premikanje
	
	COLOR = bg;
	COLOR.r = gradient(UV); // red kanal damo rezultat gradient funkcije 
	
	// množimo oz. združimo red channel z intensity in teksturo noisa
	COLOR.r = clamp(COLOR.r * bg.r * intensity * 10.0f, 0.0f, 1.0f); // klempam, da ne gre pod nulo in ne nad ena (ker je to barvni kanal)
	//	current color * intensity
	COLOR.r = floor(COLOR.r * layers) / layers; // floor ... zaokrožimo zato, ker ker je št. lejerja zmeraj cela številka ... delimo z lejerji, da je vsak lejer na 0.2 vrednosti
	COLOR.a = float(COLOR.r > 0.0f); // ?
	
	COLOR = colorize(COLOR.r, COLOR.a); // igranje z barvami
	
	
}"

[sub_resource type="ShaderMaterial" id=22]
shader = SubResource( 21 )
shader_param/intensity = 1.0
shader_param/layers = 4.0
shader_param/speed = 4.0

[sub_resource type="Shader" id=23]
code = "shader_type canvas_item;
render_mode blend_mix ;

uniform float intensity = 0.5f;
uniform float layers = 5.0f;
uniform float speed = 4.0f;

float gradient(vec2 uv){
	
	// čekiramo razdaljo od centra sprajta do koordinate trenutne pike
//	return (0.5f - distance(vec2(uv.x, uv.y), vec2(0.5f, 0.5f))); // nastane krog, ker je razdalja od centra konstantna
//	return (0.5f - distance(vec2(0.0f, uv.y), vec2(0.0f, 0.5f))); // gradient from top to bottom, focus middle
	return (1.0f - distance(vec2(0.0f, uv.y), vec2(0.0f, 1.0f))); // gradient from top
//	return (1.0f - distance(vec2(0.0f, uv.y), vec2(0.0f, 0.0f))); // gradient from bottom
}

vec4 colorize (float col, float a) {
	
	vec4 pallete;
	
//	// grayscale
//	pallete = vec4(col, col, col, a);  // col je podan red kanal

//	// monochrome
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.g = float(col >= 0.0f); // en kanal setamo, da je ves čas 0, razen ko je poln (? ... full je white?)
	
//	// darken vse kar ni belo
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.g = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.b = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
	
//	// raznobarvno
	pallete = vec4(col, col, col, a);  // col je podan red kanal
	pallete.r = float(col > 0.3 && col < 0.7 || col > 0.9); 
	pallete.g = float(col > 0.7); // višja vrednost od dveh ...?
	pallete.b = float(col > 0.5 || col > 0.9); // višja vrednost od dveh ...?
	
//	// ta bi bila za ščit
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.g = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.b = float(col > 0.3); // višja vrednost od dveh ...?
	
	return pallete; // ta vrednost gre v barvo
}


void fragment(){
	vec4 bg = texture(TEXTURE, UV - TIME/speed); // tukjaj je že notri premikanje
	
	COLOR = bg;
	COLOR.r = gradient(UV); // red kanal damo rezultat gradient funkcije 
	
	// množimo oz. združimo red channel z intensity in teksturo noisa
	COLOR.r = clamp(COLOR.r * bg.r * intensity * 10.0f, 0.0f, 1.0f); // klempam, da ne gre pod nulo in ne nad ena (ker je to barvni kanal)
	//	current color * intensity
	COLOR.r = floor(COLOR.r * layers) / layers; // floor ... zaokrožimo zato, ker ker je št. lejerja zmeraj cela številka ... delimo z lejerji, da je vsak lejer na 0.2 vrednosti
	COLOR.a = float(COLOR.r > 0.0f); // ?
	
	COLOR = colorize(COLOR.r, COLOR.a); // igranje z barvami
	
	
}"

[sub_resource type="ShaderMaterial" id=24]
shader = SubResource( 23 )
shader_param/intensity = 1.0
shader_param/layers = 4.0
shader_param/speed = 4.0

[sub_resource type="Shader" id=19]
code = "shader_type canvas_item;
render_mode blend_mix ;

uniform float intensity = 0.5f;
uniform float layers = 5.0f;
uniform float speed = 4.0f;

float gradient(vec2 uv){
	
	// čekiramo razdaljo od centra sprajta do koordinate trenutne pike
//	return (0.5f - distance(vec2(uv.x, uv.y), vec2(0.5f, 0.5f))); // nastane krog, ker je razdalja od centra konstantna
//	return (0.5f - distance(vec2(0.0f, uv.y), vec2(0.0f, 0.5f))); // gradient from top to bottom, focus middle
//	return (1.0f - distance(vec2(0.0f, uv.y), vec2(0.0f, 0.0f))); // gradient from top
	return (1.0f - distance(vec2(0.0f, uv.y), vec2(0.0f, 0.0f))); // gradient from bottom
}

vec4 colorize (float col, float a) {
	
	vec4 pallete;
	
//	// grayscale
//	pallete = vec4(col, col, col, a);  // col je podan red kanal

//	// monochrome
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.g = float(col >= 0.0f); // en kanal setamo, da je ves čas 0, razen ko je poln (? ... full je white?)
	
//	// darken vse kar ni belo
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.g = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.b = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
	
//	// raznobarvno
	pallete = vec4(col, col, col, a);  // col je podan red kanal
	pallete.r = float(col > 0.3 && col < 0.7 || col > 0.9); 
	pallete.g = float(col > 0.7); // višja vrednost od dveh ...?
	pallete.b = float(col > 0.5 || col > 0.9); // višja vrednost od dveh ...?
	
//	// ta bi bila za ščit
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.g = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.b = float(col > 0.3); // višja vrednost od dveh ...?
	
	return pallete; // ta vrednost gre v barvo
}


void fragment(){
	vec4 bg = texture(TEXTURE, UV - TIME/speed); // tukjaj je že notri premikanje
	
	COLOR = bg;
	COLOR.r = gradient(UV); // red kanal damo rezultat gradient funkcije 
	
	// množimo oz. združimo red channel z intensity in teksturo noisa
	COLOR.r = clamp(COLOR.r * bg.r * intensity * 10.0f, 0.0f, 1.0f); // klempam, da ne gre pod nulo in ne nad ena (ker je to barvni kanal)
	//	current color * intensity
	COLOR.r = floor(COLOR.r * layers) / layers; // floor ... zaokrožimo zato, ker ker je št. lejerja zmeraj cela številka ... delimo z lejerji, da je vsak lejer na 0.2 vrednosti
	COLOR.a = float(COLOR.r > 0.0f); // ?
	
	COLOR = colorize(COLOR.r, COLOR.a); // igranje z barvami
	
	
}"

[sub_resource type="ShaderMaterial" id=20]
shader = SubResource( 19 )
shader_param/intensity = 1.0
shader_param/layers = 4.0
shader_param/speed = 4.0

[sub_resource type="Shader" id=107]
code = "shader_type canvas_item;
render_mode blend_mix;

uniform float max_line_width = 10.0;
uniform float min_line_width = 5.0;
uniform float freq = 1.0;
uniform float block_size = 20.0;
uniform vec4 starting_colour = vec4(0,0,0,1);
uniform vec4 ending_colour = vec4(1);

const float pi = 3.1415;
const int ang_res = 16;
const int grad_res = 8;

float hash(vec2 p, float s) {
	return fract(35.1 * sin(dot(vec3(112.3, 459.2, 753.2), vec3(p, s))));
}

float noise(vec2 p, float s) {
	vec2 d = vec2(0, 1);
	vec2 b = floor(p);
	vec2 f = fract(p);
	return mix(
		mix(hash(b + d.xx, s), hash(b + d.yx, s), f.x),
		mix(hash(b + d.xy, s), hash(b + d.yy, s), f.x), f.y);
}

float getLineWidth(vec2 p, float s) {
	p /= block_size;
	float w = 0.0;
	float intensity = 1.0;
	for (int i = 0; i < 3; i++) {
		w = mix(w, noise(p, s), intensity);
		p /= 2.0;
		intensity /= 2.0;
	}
	
	return mix(max_line_width, min_line_width, w);
}

bool pixelInRange(sampler2D text, vec2 uv, vec2 dist) {
	float alpha = 0.0;
	for (int i = 0; i < ang_res; i++) {
		float angle = 2.0 * pi * float(i) / float(ang_res);
		vec2 disp = dist * vec2(cos(angle), sin(angle));
		if (texture(text, uv + disp).a > 0.0) return true;
	}
	return false;
}

float getClosestDistance(sampler2D text, vec2 uv, vec2 maxDist) {
	if (!pixelInRange(text, uv, maxDist)) return -1.0;
	
	float hi = 1.0; float lo = 0.0;
	
	for (int i = 1; i <= grad_res; i++) {
		float curr = (hi + lo) / 2.0;
		if (pixelInRange(text, uv, curr * maxDist)) {
			hi = curr;
		}
		else {
			lo = curr;
		}
	}
	return hi;
	
}

void fragment() {
	float timeStep = floor(freq * TIME);
	vec2 scaledDist = TEXTURE_PIXEL_SIZE;
	scaledDist *= getLineWidth(UV / TEXTURE_PIXEL_SIZE, timeStep);
	float w = getClosestDistance(TEXTURE, UV, scaledDist);
	
	if (( w > 0.0) && (texture(TEXTURE, UV).a < 0.2)) {
		COLOR = mix(starting_colour, ending_colour, tanh(3.0*w));
	}
	else {
		COLOR = texture(TEXTURE, UV);
	}
	
}"

[sub_resource type="ShaderMaterial" id=97]
shader = SubResource( 107 )
shader_param/max_line_width = 10.0
shader_param/min_line_width = 4.0
shader_param/freq = 7.0
shader_param/block_size = 5.0
shader_param/starting_colour = Plane( 1, 0, 1, 1 )
shader_param/ending_colour = Plane( 1, 0, 1, 0 )

[node name="Arena" type="Node2D"]
script = ExtResource( 1 )
__meta__ = {
"_edit_horizontal_guides_": [ -64.0 ]
}

[node name="Background" type="Node2D" parent="."]
modulate = Color( 0.054902, 0.709804, 0.498039, 1 )

[node name="ColorRect" type="ColorRect" parent="Background"]
margin_left = 1.0
margin_top = 11.0
margin_right = 641.0
margin_bottom = 371.0
rect_min_size = Vector2( 640, 360 )
color = Color( 0.796078, 0.796078, 0.796078, 1 )

[node name="Light2D" type="Light2D" parent="Background"]
visible = false
position = Vector2( 320.5, 181 )
scale = Vector2( 1.95988, 1.10416 )
z_index = 1
texture = ExtResource( 5 )
texture_scale = 2.92
color = Color( 1, 1, 0.388235, 1 )
energy = 0.69

[node name="EffectsLayer Z1" type="CanvasLayer" parent="."]

[node name="Shadows" type="Sprite" parent="EffectsLayer Z1"]
modulate = Color( 1, 1, 1, 0.752941 )
material = SubResource( 88 )
texture = SubResource( 92 )
centered = false
flip_v = true

[node name="Colors" type="Sprite" parent="EffectsLayer Z1"]
modulate = Color( 1, 1, 1, 0.752941 )
material = SubResource( 86 )
texture = SubResource( 93 )
centered = false
flip_v = true

[node name="Viewport" type="Viewport" parent="EffectsLayer Z1"]
size = Vector2( 640, 360 )
transparent_bg = true
hdr = false
usage = 0

[node name="Effects" type="Node2D" parent="EffectsLayer Z1/Viewport"]
script = ExtResource( 9 )

[node name="EngineParticles" type="CPUParticles2D" parent="EffectsLayer Z1/Viewport/Effects"]
position = Vector2( 150, 150 )
rotation = 0.785398
scale = Vector2( 2, 2 )
emitting = false
amount = 500
lifetime = 0.5
randomness = 0.5
lifetime_randomness = 0.5
local_coords = false
emission_shape = 2
emission_rect_extents = Vector2( 0.7, 0.7 )
direction = Vector2( 0, 1 )
spread = 0.0
gravity = Vector2( 0, 10 )
initial_velocity = 80.0
initial_velocity_random = 0.5
linear_accel = -20.0
linear_accel_random = 1.0
damping_curve = SubResource( 5 )
color_ramp = SubResource( 58 )

[node name="Particles2D_eksplozija" type="Particles2D" parent="EffectsLayer Z1/Viewport/Effects"]
position = Vector2( 85, 30 )
emitting = false
amount = 1000
explosiveness = 1.0
process_material = SubResource( 7 )
texture = ExtResource( 6 )

[node name="Particles2D_implozija" type="Particles2D" parent="EffectsLayer Z1/Viewport/Effects"]
position = Vector2( 219, 76 )
scale = Vector2( 1.00686, 0.559279 )
emitting = false
amount = 1000
explosiveness = 0.61
process_material = SubResource( 14 )
texture = ExtResource( 6 )

[node name="dobra eksplozija" type="CPUParticles2D" parent="EffectsLayer Z1/Viewport/Effects"]
position = Vector2( 309, 172 )
emitting = false
amount = 89
speed_scale = 0.5
explosiveness = 1.0
emission_shape = 3
emission_points = PoolVector2Array( 0, 5, 0, 6, 1, 4, 1, 5, 1, 6, 1, 7, 2, 2, 2, 3, 2, 4, 2, 5, 2, 6, 3, 1, 3, 2, 3, 3, 3, 4, 3, 5, 3, 6, 3, 7, 4, 3, 4, 5, 4, 7, 5, 1, 5, 2, 5, 3, 5, 4, 5, 5, 5, 6, 5, 7, 6, 2, 6, 3, 6, 4, 6, 5, 6, 6, 7, 4, 7, 5, 7, 6, 7, 7, 8, 5, 8, 6 )
emission_colors = PoolColorArray( 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 )
direction = Vector2( 1, 1 )
spread = 180.0
gravity = Vector2( 0, 0 )
initial_velocity = 0.01
linear_accel = 100.0
linear_accel_random = 0.53
linear_accel_curve = SubResource( 9 )
color_ramp = SubResource( 10 )

[node name="BodiesLayer Z2" type="CanvasLayer" parent="."]
layer = 2
script = ExtResource( 8 )

[node name="Player" parent="BodiesLayer Z2" instance=ExtResource( 2 )]
position = Vector2( 73, 126 )

[node name="Shadows" type="ColorRect" parent="BodiesLayer Z2"]
material = SubResource( 63 )
margin_right = 640.0
margin_bottom = 360.0
rect_min_size = Vector2( 640, 360 )

[node name="Colors" type="ColorRect" parent="BodiesLayer Z2"]
material = SubResource( 16 )
margin_right = 640.0
margin_bottom = 360.0
rect_min_size = Vector2( 640, 360 )

[node name="LevelLayer Z3" type="CanvasLayer" parent="."]
layer = 3

[node name="obsticles" type="Node2D" parent="LevelLayer Z3"]
visible = false

[node name="1" type="StaticBody2D" parent="LevelLayer Z3/obsticles"]
modulate = Color( 0, 0, 0, 1 )
position = Vector2( -230, -39 )
scale = Vector2( 1.0034, 1 )
script = ExtResource( 4 )
__meta__ = {
"_edit_group_": true
}

[node name="CollisionPolygon2D" type="CollisionPolygon2D" parent="LevelLayer Z3/obsticles/1"]
visible = false
polygon = PoolVector2Array( 375, 152, 367, 173, 401, 175, 393, 148 )
disabled = true

[node name="Polygon2D" type="Polygon2D" parent="LevelLayer Z3/obsticles/1"]
polygon = PoolVector2Array( 375, 152, 367, 173, 401, 175, 393, 148 )

[node name="2" type="Area2D" parent="LevelLayer Z3/obsticles"]
modulate = Color( 1, 0, 0, 1 )
position = Vector2( 430, 123 )
__meta__ = {
"_edit_group_": true
}

[node name="CollisionPolygon2D" type="CollisionPolygon2D" parent="LevelLayer Z3/obsticles/2"]
visible = false
polygon = PoolVector2Array( -18, -19, -8, 20, 19, 15, 21, -18 )
disabled = true

[node name="CollisionPolygon2D2" type="Polygon2D" parent="LevelLayer Z3/obsticles/2"]
polygon = PoolVector2Array( -18, -19, -8, 20, 19, 15, 21, -18 )

[node name="3" type="StaticBody2D" parent="LevelLayer Z3/obsticles"]
position = Vector2( 369, 267 )
script = ExtResource( 4 )
__meta__ = {
"_edit_group_": true
}

[node name="CollisionPolygon2D" type="CollisionPolygon2D" parent="LevelLayer Z3/obsticles/3"]
visible = false
polygon = PoolVector2Array( -19, -14, -17, 15, 32, 20, 16, -11 )
disabled = true

[node name="Polygon2D" type="Polygon2D" parent="LevelLayer Z3/obsticles/3"]
position = Vector2( 106, 54 )
polygon = PoolVector2Array( -125, -67, -123, -39, -75, -34, -89, -66 )

[node name="4" type="Area2D" parent="LevelLayer Z3/obsticles"]
modulate = Color( 0, 0, 1, 1 )
position = Vector2( 168, 235 )
__meta__ = {
"_edit_group_": true
}

[node name="CollisionPolygon2D" type="CollisionPolygon2D" parent="LevelLayer Z3/obsticles/4"]
visible = false
polygon = PoolVector2Array( -18, -19, -8, 20, 19, 15, 21, -18 )
disabled = true

[node name="CollisionPolygon2D2" type="Polygon2D" parent="LevelLayer Z3/obsticles/4"]
polygon = PoolVector2Array( -18, -19, -8, 20, 19, 15, 21, -18 )

[node name="Level_00" type="Node2D" parent="LevelLayer Z3"]
z_index = -1

[node name="EdgeTilemap" type="TileMap" parent="LevelLayer Z3/Level_00"]
z_index = -1
tile_set = ExtResource( 3 )
cell_size = Vector2( 8, 8 )
cell_custom_transform = Transform2D( 8, 0, 0, 8, 0, 0 )
format = 1
tile_data = PoolIntArray( -655392, 2, 0, -655391, 2, 0, -655390, 2, 0, -655389, 2, 0, -655388, 2, 0, -589851, 2, 0, -524314, 2, 0, -262139, 2, 65536, -262138, 2, 3, -262137, 2, 3, -262136, 2, 3, -262135, 2, 2, -262134, 2, 2, -262133, 2, 3, -262132, 2, 3, -262131, 2, 2, -262130, 2, 3, -262129, 2, 2, -262128, 2, 3, -262127, 2, 65541, -262078, 2, 0, -196603, 2, 131072, -196602, 2, 131074, -196601, 2, 131074, -196600, 2, 131074, -196599, 2, 131074, -196598, 2, 131074, -196597, 2, 131074, -196596, 2, 131074, -196595, 2, 131074, -196594, 2, 131074, -196593, 2, 131074, -196592, 2, 131074, -196591, 2, 262145, -196590, 2, 3, -196589, 2, 2, -196588, 2, 2, -196587, 2, 3, -196586, 2, 2, -196585, 2, 2, -196584, 2, 3, -196583, 2, 2, -196582, 2, 2, -196581, 2, 2, -196580, 2, 2, -196579, 2, 3, -196578, 2, 4, -196553, 2, 1, -196552, 2, 3, -196551, 2, 3, -196550, 2, 2, -196549, 2, 3, -196548, 2, 2, -196547, 2, 2, -196546, 2, 3, -196545, 2, 2, -196544, 2, 2, -196543, 2, 2, -196542, 2, 2, -196541, 2, 3, -196540, 2, 2, -196539, 2, 3, -196538, 2, 3, -196537, 2, 2, -196536, 2, 2, -196535, 2, 2, -196534, 2, 3, -196533, 2, 3, -196532, 2, 3, -196531, 2, 2, -196530, 2, 2, -196529, 2, 3, -196528, 2, 65541, -131067, 2, 196608, -131066, 2, 131074, -131065, 2, 131074, -131064, 2, 131074, -131063, 2, 131074, -131062, 2, 131074, -131061, 2, 131074, -131060, 2, 131074, -131059, 2, 131074, -131058, 2, 131074, -131057, 2, 131074, -131056, 2, 131074, -131055, 2, 131074, -131054, 2, 131074, -131053, 2, 131074, -131052, 2, 131074, -131051, 2, 131074, -131050, 2, 131074, -131049, 2, 131074, -131048, 2, 131074, -131047, 2, 131074, -131046, 2, 131074, -131045, 2, 131074, -131044, 2, 131074, -131043, 2, 131074, -131042, 2, 262145, -131041, 2, 2, -131040, 2, 3, -131039, 2, 2, -131038, 2, 2, -131037, 2, 2, -131036, 2, 2, -131035, 2, 2, -131034, 2, 2, -131033, 2, 2, -131032, 2, 2, -131031, 2, 3, -131030, 2, 2, -131029, 2, 2, -131028, 2, 3, -131027, 2, 3, -131026, 2, 3, -131025, 2, 2, -131024, 2, 2, -131023, 2, 3, -131022, 2, 3, -131021, 2, 3, -131020, 2, 2, -131019, 2, 2, -131018, 2, 3, -131017, 2, 262148, -131016, 2, 131074, -131015, 2, 131074, -131014, 2, 131074, -131013, 2, 131074, -131012, 2, 131074, -131011, 2, 131074, -131010, 2, 131074, -131009, 2, 131074, -131008, 2, 131074, -131007, 2, 131074, -131006, 2, 131074, -131005, 2, 131074, -131004, 2, 131074, -131003, 2, 131074, -131002, 2, 131074, -131001, 2, 131074, -131000, 2, 131074, -130999, 2, 131074, -130998, 2, 131074, -130997, 2, 131074, -130996, 2, 131074, -130995, 2, 131074, -130994, 2, 131074, -130993, 2, 131074, -130992, 2, 262145, -130991, 2, 3, -130990, 2, 65541, -65531, 2, 196608, -65530, 2, 131074, -65529, 2, 131074, -65528, 2, 131074, -65527, 2, 131074, -65526, 2, 131074, -65525, 2, 131074, -65524, 2, 131074, -65523, 2, 131074, -65522, 2, 131074, -65521, 2, 131074, -65520, 2, 131074, -65519, 2, 131074, -65518, 2, 131074, -65517, 2, 131074, -65516, 2, 131074, -65515, 2, 131074, -65514, 2, 131074, -65513, 2, 131074, -65512, 2, 131074, -65511, 2, 131074, -65510, 2, 131074, -65509, 2, 131074, -65508, 2, 131074, -65507, 2, 131074, -65506, 2, 131074, -65505, 2, 131074, -65504, 2, 131074, -65503, 2, 131074, -65502, 2, 131074, -65501, 2, 131074, -65500, 2, 131074, -65499, 2, 131074, -65498, 2, 131074, -65497, 2, 131074, -65496, 2, 131074, -65495, 2, 131074, -65494, 2, 131074, -65493, 2, 131074, -65492, 2, 131074, -65491, 2, 131074, -65490, 2, 131074, -65489, 2, 131074, -65488, 2, 131074, -65487, 2, 131074, -65486, 2, 131074, -65485, 2, 131074, -65484, 2, 131074, -65483, 2, 131074, -65482, 2, 131074, -65481, 2, 131074, -65480, 2, 131074, -65479, 2, 131074, -65478, 2, 65537, -65477, 2, 327682, -65476, 2, 327683, -65475, 2, 65540, -65474, 2, 131074, -65473, 2, 131074, -65472, 2, 131074, -65471, 2, 131074, -65470, 2, 131074, -65469, 2, 131074, -65468, 2, 131074, -65467, 2, 131074, -65466, 2, 131074, -65465, 2, 131074, -65464, 2, 131074, -65463, 2, 131074, -65462, 2, 131074, -65461, 2, 131074, -65460, 2, 131074, -65459, 2, 131074, -65458, 2, 131074, -65457, 2, 131074, -65456, 2, 131074, -65455, 2, 131074, -65454, 2, 196613, 5, 2, 327681, 6, 2, 327683, 7, 2, 327683, 8, 2, 327683, 9, 2, 327682, 10, 2, 327683, 11, 2, 327682, 12, 2, 327682, 13, 2, 327683, 14, 2, 327682, 15, 2, 327682, 16, 2, 327682, 17, 2, 327682, 18, 2, 327683, 19, 2, 65540, 20, 2, 131074, 21, 2, 131074, 22, 2, 131074, 23, 2, 131074, 24, 2, 131074, 25, 2, 131074, 26, 2, 131074, 27, 2, 131074, 28, 2, 131074, 29, 2, 131074, 30, 2, 131074, 31, 2, 131074, 32, 2, 131074, 33, 2, 65537, 34, 2, 327683, 35, 2, 327682, 36, 2, 327682, 37, 2, 327683, 38, 2, 327683, 39, 2, 327683, 40, 2, 327683, 41, 2, 327683, 42, 2, 327682, 43, 2, 327682, 44, 2, 327683, 45, 2, 327683, 46, 2, 327682, 47, 2, 327682, 48, 2, 327682, 49, 2, 327682, 50, 2, 327682, 51, 2, 327683, 52, 2, 327682, 53, 2, 327682, 54, 2, 327682, 55, 2, 327682, 56, 2, 327682, 57, 2, 327683, 58, 2, 262149, 61, 2, 327681, 62, 2, 327683, 63, 2, 327683, 64, 2, 327683, 65, 2, 327682, 66, 2, 327683, 67, 2, 327682, 68, 2, 327683, 69, 2, 327682, 70, 2, 65540, 71, 2, 131074, 72, 2, 131074, 73, 2, 131074, 74, 2, 131074, 75, 2, 131074, 76, 2, 131074, 77, 2, 131074, 78, 2, 131074, 79, 2, 131074, 80, 2, 131074, 81, 2, 131074, 82, 2, 196613, 65555, 2, 327681, 65556, 2, 327683, 65557, 2, 327683, 65558, 2, 327683, 65559, 2, 327683, 65560, 2, 327683, 65561, 2, 327683, 65562, 2, 327683, 65563, 2, 327682, 65564, 2, 327682, 65565, 2, 327682, 65566, 2, 327682, 65567, 2, 327683, 65568, 2, 327683, 65569, 2, 262149, 65599, 2, 0, 65602, 2, 0, 65606, 2, 262144, 65607, 2, 327683, 65608, 2, 65540, 65609, 2, 131074, 65610, 2, 131074, 65611, 2, 65537, 65612, 2, 327682, 65613, 2, 65540, 65614, 2, 131074, 65615, 2, 131074, 65616, 2, 131074, 65617, 2, 131074, 65618, 2, 196613, 131144, 2, 262144, 131145, 2, 327683, 131146, 2, 327682, 131147, 2, 327684, 131149, 2, 262144, 131150, 2, 327683, 131151, 2, 65540, 131152, 2, 131074, 131153, 2, 131074, 131154, 2, 131077, 262139, 2, 65536, 262140, 2, 3, 262141, 2, 2, 262142, 2, 2, 262143, 2, 2, 196608, 2, 65541, 196687, 2, 131072, 196688, 2, 131074, 196689, 2, 131074, 196690, 2, 196613, 327675, 2, 196608, 327676, 2, 131074, 327677, 2, 131074, 327678, 2, 131074, 327679, 2, 131074, 262144, 2, 131077, 262223, 2, 131072, 262224, 2, 131074, 262225, 2, 65537, 262226, 2, 327684, 393211, 2, 131072, 393212, 2, 131074, 393213, 2, 131074, 393214, 2, 131074, 393215, 2, 131074, 327680, 2, 196613, 327759, 2, 196608, 327760, 2, 131074, 327761, 2, 131077, 458747, 2, 196611, 458748, 2, 65540, 458749, 2, 131074, 458750, 2, 131074, 458751, 2, 131074, 393216, 2, 131077, 393295, 2, 196608, 393296, 2, 131074, 393297, 2, 196613, 524284, 2, 131072, 524285, 2, 131074, 524286, 2, 131074, 524287, 2, 131074, 458752, 2, 131077, 458831, 2, 196608, 458832, 2, 131074, 458833, 2, 196613, 589820, 2, 131072, 589821, 2, 131074, 589822, 2, 131074, 589823, 2, 131074, 524288, 2, 131077, 524367, 2, 131072, 524368, 2, 131074, 524369, 2, 196613, 655356, 2, 327681, 655357, 2, 65540, 655358, 2, 131074, 655359, 2, 131074, 589824, 2, 196613, 589903, 2, 131072, 589904, 2, 131074, 589905, 2, 196613, 720893, 2, 196608, 720894, 2, 131074, 720895, 2, 131074, 655360, 2, 196613, 655439, 2, 196608, 655440, 2, 131074, 655441, 2, 196613, 786429, 2, 196608, 786430, 2, 131074, 786431, 2, 131074, 720896, 2, 131077, 720974, 2, 1, 720975, 2, 262148, 720976, 2, 131074, 720977, 2, 131077, 851965, 2, 131072, 851966, 2, 131074, 851967, 2, 131074, 786432, 2, 196613, 786510, 2, 196608, 786511, 2, 131074, 786512, 2, 131074, 786513, 2, 131077, 786554, 2, 0, 917501, 2, 131072, 917502, 2, 131074, 917503, 2, 131074, 851968, 2, 196613, 852046, 2, 196608, 852047, 2, 131074, 852048, 2, 131074, 852049, 2, 196613, 983036, 2, 131075, 983037, 2, 262148, 983038, 2, 131074, 983039, 2, 131074, 917504, 2, 196613, 917582, 2, 196608, 917583, 2, 131074, 917584, 2, 131074, 917585, 2, 131077, 917626, 2, 0, 1048572, 2, 327681, 1048573, 2, 65540, 1048574, 2, 131074, 1048575, 2, 131074, 983040, 2, 131077, 983118, 2, 131072, 983119, 2, 131074, 983120, 2, 131074, 983121, 2, 262145, 983122, 2, 4, 983162, 2, 0, 1114109, 2, 327681, 1114110, 2, 65540, 1114111, 2, 131074, 1048576, 2, 196613, 1048654, 2, 262144, 1048655, 2, 65540, 1048656, 2, 131074, 1048657, 2, 131074, 1048658, 2, 131077, 1048695, 2, 0, 1048700, 2, 0, 1179646, 2, 196608, 1179647, 2, 131074, 1114112, 2, 131077, 1114191, 2, 131072, 1114192, 2, 131074, 1114193, 2, 131074, 1114194, 2, 131077, 1114231, 2, 0, 1114233, 2, 0, 1114238, 2, 0, 1245182, 2, 131072, 1245183, 2, 131074, 1179648, 2, 131077, 1179727, 2, 196608, 1179728, 2, 131074, 1179729, 2, 131074, 1179730, 2, 131077, 1179769, 2, 0, 1179770, 2, 0, 1310718, 2, 196608, 1310719, 2, 131074, 1245184, 2, 196613, 1245263, 2, 196608, 1245264, 2, 131074, 1245265, 2, 65537, 1245266, 2, 262149, 1245304, 2, 0, 1376254, 2, 131072, 1376255, 2, 131074, 1310720, 2, 131077, 1310798, 2, 65536, 1310799, 2, 262148, 1310800, 2, 131074, 1310801, 2, 131077, 1310840, 2, 0, 1441790, 2, 196608, 1441791, 2, 131074, 1376256, 2, 196613, 1376334, 2, 327681, 1376335, 2, 65540, 1376336, 2, 131074, 1376337, 2, 131077, 1376376, 2, 0, 1507326, 2, 196608, 1507327, 2, 131074, 1441792, 2, 196613, 1441871, 2, 196608, 1441872, 2, 131074, 1441873, 2, 196613, 1572862, 2, 196608, 1572863, 2, 131074, 1507328, 2, 196613, 1507407, 2, 196608, 1507408, 2, 131074, 1507409, 2, 131077, 1638398, 2, 131072, 1638399, 2, 131074, 1572864, 2, 131077, 1572943, 2, 131072, 1572944, 2, 131074, 1572945, 2, 131077, 1703934, 2, 196608, 1703935, 2, 131074, 1638400, 2, 196613, 1638479, 2, 196608, 1638480, 2, 131074, 1638481, 2, 131077, 1638482, 2, 0, 1769469, 2, 1, 1769470, 2, 262148, 1769471, 2, 131074, 1703936, 2, 196613, 1704015, 2, 196608, 1704016, 2, 131074, 1704017, 2, 131077, 1835005, 2, 131072, 1835006, 2, 131074, 1835007, 2, 131074, 1769472, 2, 131077, 1769551, 2, 196608, 1769552, 2, 131074, 1769553, 2, 131077, 1900541, 2, 131072, 1900542, 2, 131074, 1900543, 2, 131074, 1835008, 2, 196613, 1835087, 2, 262144, 1835088, 2, 65540, 1835089, 2, 262145, 1835090, 2, 65541, 1966077, 2, 131072, 1966078, 2, 131074, 1966079, 2, 131074, 1900544, 2, 131077, 1900624, 2, 196608, 1900625, 2, 131074, 1900626, 2, 131077, 2031613, 2, 131072, 2031614, 2, 131074, 2031615, 2, 131074, 1966080, 2, 196613, 1966159, 2, 0, 1966160, 2, 327681, 1966161, 2, 327683, 1966162, 2, 262149, 2097149, 2, 131072, 2097150, 2, 131074, 2097151, 2, 131074, 2031616, 2, 131077, 2162685, 2, 196608, 2162686, 2, 131074, 2162687, 2, 131074, 2097152, 2, 196613, 2228221, 2, 196608, 2228222, 2, 131074, 2228223, 2, 131074, 2162688, 2, 131077, 2293757, 2, 196608, 2293758, 2, 131074, 2293759, 2, 131074, 2228224, 2, 196613, 2359293, 2, 131072, 2359294, 2, 131074, 2359295, 2, 131074, 2293760, 2, 196613, 2424829, 2, 262144, 2424830, 2, 65540, 2424831, 2, 131074, 2359296, 2, 196613, 2490366, 2, 131072, 2490367, 2, 131074, 2424832, 2, 131077, 2555901, 2, 0, 2555902, 2, 131072, 2555903, 2, 131074, 2490368, 2, 196613, 2490447, 2, 1, 2490448, 2, 3, 2490449, 2, 3, 2490450, 2, 65541, 2621438, 2, 131072, 2621439, 2, 131074, 2555904, 2, 196613, 2555983, 2, 196608, 2555984, 2, 131074, 2555985, 2, 131074, 2555986, 2, 262145, 2555987, 2, 65541, 2686974, 2, 196608, 2686975, 2, 131074, 2621440, 2, 196613, 2621519, 2, 131072, 2621520, 2, 131074, 2621521, 2, 131074, 2621522, 2, 131074, 2621523, 2, 196613, 2752510, 2, 131072, 2752511, 2, 131074, 2686976, 2, 196613, 2687055, 2, 131072, 2687056, 2, 131074, 2687057, 2, 131074, 2687058, 2, 131074, 2687059, 2, 196613, 2818045, 2, 65536, 2818046, 2, 262148, 2818047, 2, 131074, 2752512, 2, 262145, 2752513, 2, 4, 2752590, 2, 1, 2752591, 2, 262148, 2752592, 2, 131074, 2752593, 2, 131074, 2752594, 2, 131074, 2752595, 2, 196613, 2883581, 2, 262144, 2883582, 2, 65540, 2883583, 2, 131074, 2818048, 2, 131074, 2818049, 2, 196613, 2818054, 2, 65536, 2818055, 2, 2, 2818056, 2, 2, 2818057, 2, 3, 2818058, 2, 3, 2818059, 2, 2, 2818060, 2, 2, 2818061, 2, 3, 2818062, 2, 4, 2818072, 2, 65536, 2818073, 2, 3, 2818074, 2, 3, 2818075, 2, 3, 2818076, 2, 2, 2818077, 2, 3, 2818078, 2, 65541, 2818082, 2, 1, 2818083, 2, 2, 2818084, 2, 3, 2818085, 2, 2, 2818086, 2, 2, 2818087, 2, 3, 2818088, 2, 2, 2818089, 2, 2, 2818090, 2, 3, 2818091, 2, 4, 2818123, 2, 1, 2818124, 2, 3, 2818125, 2, 3, 2818126, 2, 262148, 2818127, 2, 131074, 2818128, 2, 131074, 2818129, 2, 131074, 2818130, 2, 131074, 2818131, 2, 196613, 2949118, 2, 131072, 2949119, 2, 131074, 2883584, 2, 131074, 2883585, 2, 262145, 2883586, 2, 2, 2883587, 2, 3, 2883588, 2, 3, 2883589, 2, 3, 2883590, 2, 262148, 2883591, 2, 131074, 2883592, 2, 131074, 2883593, 2, 131074, 2883594, 2, 131074, 2883595, 2, 131074, 2883596, 2, 131074, 2883597, 2, 131074, 2883598, 2, 262145, 2883599, 2, 3, 2883600, 2, 3, 2883601, 2, 2, 2883602, 2, 3, 2883603, 2, 3, 2883604, 2, 3, 2883605, 2, 2, 2883606, 2, 2, 2883607, 2, 3, 2883608, 2, 262148, 2883609, 2, 131074, 2883610, 2, 131074, 2883611, 2, 131074, 2883612, 2, 131074, 2883613, 2, 131074, 2883614, 2, 262145, 2883615, 2, 2, 2883616, 2, 2, 2883617, 2, 2, 2883618, 2, 262148, 2883619, 2, 131074, 2883620, 2, 131074, 2883621, 2, 131074, 2883622, 2, 131074, 2883623, 2, 131074, 2883624, 2, 131074, 2883625, 2, 131074, 2883626, 2, 131074, 2883627, 2, 262145, 2883628, 2, 3, 2883629, 2, 2, 2883630, 2, 2, 2883631, 2, 3, 2883632, 2, 3, 2883633, 2, 3, 2883634, 2, 3, 2883635, 2, 3, 2883636, 2, 2, 2883637, 2, 3, 2883638, 2, 3, 2883639, 2, 2, 2883640, 2, 3, 2883641, 2, 3, 2883642, 2, 2, 2883643, 2, 3, 2883644, 2, 3, 2883645, 2, 3, 2883646, 2, 3, 2883647, 2, 3, 2883648, 2, 2, 2883649, 2, 2, 2883650, 2, 3, 2883651, 2, 3, 2883652, 2, 3, 2883653, 2, 2, 2883654, 2, 2, 2883655, 2, 2, 2883656, 2, 2, 2883657, 2, 2, 2883658, 2, 3, 2883659, 2, 262148, 2883660, 2, 131074, 2883661, 2, 131074, 2883662, 2, 131074, 2883663, 2, 131074, 2883664, 2, 131074, 2883665, 2, 131074, 2883666, 2, 131074, 2883667, 2, 131077, 3014654, 2, 131072, 3014655, 2, 131074, 2949120, 2, 131074, 2949121, 2, 131074, 2949122, 2, 131074, 2949123, 2, 131074, 2949124, 2, 131074, 2949125, 2, 131074, 2949126, 2, 131074, 2949127, 2, 131074, 2949128, 2, 131074, 2949129, 2, 131074, 2949130, 2, 131074, 2949131, 2, 131074, 2949132, 2, 131074, 2949133, 2, 131074, 2949134, 2, 131074, 2949135, 2, 131074, 2949136, 2, 131074, 2949137, 2, 131074, 2949138, 2, 131074, 2949139, 2, 131074, 2949140, 2, 131074, 2949141, 2, 131074, 2949142, 2, 131074, 2949143, 2, 131074, 2949144, 2, 131074, 2949145, 2, 131074, 2949146, 2, 131074, 2949147, 2, 131074, 2949148, 2, 131074, 2949149, 2, 131074, 2949150, 2, 131074, 2949151, 2, 131074, 2949152, 2, 131074, 2949153, 2, 131074, 2949154, 2, 131074, 2949155, 2, 131074, 2949156, 2, 131074, 2949157, 2, 131074, 2949158, 2, 131074, 2949159, 2, 131074, 2949160, 2, 131074, 2949161, 2, 131074, 2949162, 2, 131074, 2949163, 2, 131074, 2949164, 2, 131074, 2949165, 2, 131074, 2949166, 2, 131074, 2949167, 2, 131074, 2949168, 2, 131074, 2949169, 2, 131074, 2949170, 2, 131074, 2949171, 2, 131074, 2949172, 2, 131074, 2949173, 2, 131074, 2949174, 2, 131074, 2949175, 2, 131074, 2949176, 2, 131074, 2949177, 2, 131074, 2949178, 2, 131074, 2949179, 2, 131074, 2949180, 2, 131074, 2949181, 2, 131074, 2949182, 2, 131074, 2949183, 2, 131074, 2949184, 2, 131074, 2949185, 2, 131074, 2949186, 2, 131074, 2949187, 2, 131074, 2949188, 2, 131074, 2949189, 2, 131074, 2949190, 2, 131074, 2949191, 2, 131074, 2949192, 2, 131074, 2949193, 2, 131074, 2949194, 2, 131074, 2949195, 2, 131074, 2949196, 2, 131074, 2949197, 2, 131074, 2949198, 2, 131074, 2949199, 2, 131074, 2949200, 2, 131074, 2949201, 2, 131074, 2949202, 2, 131074, 2949203, 2, 196613, 3080190, 2, 196608, 3080191, 2, 65537, 3014656, 2, 327682, 3014657, 2, 65540, 3014658, 2, 131074, 3014659, 2, 131074, 3014660, 2, 131074, 3014661, 2, 131074, 3014662, 2, 131074, 3014663, 2, 131074, 3014664, 2, 131074, 3014665, 2, 131074, 3014666, 2, 131074, 3014667, 2, 131074, 3014668, 2, 131074, 3014669, 2, 131074, 3014670, 2, 131074, 3014671, 2, 131074, 3014672, 2, 131074, 3014673, 2, 131074, 3014674, 2, 131074, 3014675, 2, 131074, 3014676, 2, 131074, 3014677, 2, 131074, 3014678, 2, 131074, 3014679, 2, 131074, 3014680, 2, 131074, 3014681, 2, 131074, 3014682, 2, 131074, 3014683, 2, 131074, 3014684, 2, 131074, 3014685, 2, 131074, 3014686, 2, 131074, 3014687, 2, 131074, 3014688, 2, 131074, 3014689, 2, 131074, 3014690, 2, 131074, 3014691, 2, 131074, 3014692, 2, 131074, 3014693, 2, 131074, 3014694, 2, 131074, 3014695, 2, 131074, 3014696, 2, 131074, 3014697, 2, 131074, 3014698, 2, 131074, 3014699, 2, 131074, 3014700, 2, 131074, 3014701, 2, 131074, 3014702, 2, 131074, 3014703, 2, 131074, 3014704, 2, 131074, 3014705, 2, 131074, 3014706, 2, 131074, 3014707, 2, 131074, 3014708, 2, 131074, 3014709, 2, 131074, 3014710, 2, 131074, 3014711, 2, 131074, 3014712, 2, 131074, 3014713, 2, 131074, 3014714, 2, 131074, 3014715, 2, 131074, 3014716, 2, 131074, 3014717, 2, 131074, 3014718, 2, 65537, 3014719, 2, 327682, 3014720, 2, 327682, 3014721, 2, 327683, 3014722, 2, 327683, 3014723, 2, 327683, 3014724, 2, 327683, 3014725, 2, 327683, 3014726, 2, 327683, 3014727, 2, 327682, 3014728, 2, 65540, 3014729, 2, 131074, 3014730, 2, 131074, 3014731, 2, 131074, 3014732, 2, 131074, 3014733, 2, 131074, 3014734, 2, 131074, 3014735, 2, 131074, 3014736, 2, 131074, 3014737, 2, 131074, 3014738, 2, 131074, 3014739, 2, 131077, 3014845, 2, 0, 3145726, 2, 327681, 3145727, 2, 262149, 3080193, 2, 327681, 3080194, 2, 327683, 3080195, 2, 327683, 3080196, 2, 327682, 3080197, 2, 327682, 3080198, 2, 327682, 3080199, 2, 327683, 3080200, 2, 327683, 3080201, 2, 327683, 3080202, 2, 327682, 3080203, 2, 327683, 3080204, 2, 327682, 3080205, 2, 327682, 3080206, 2, 327683, 3080207, 2, 327682, 3080208, 2, 327683, 3080209, 2, 327682, 3080210, 2, 327682, 3080211, 2, 327682, 3080212, 2, 327682, 3080213, 2, 327682, 3080214, 2, 327682, 3080215, 2, 327683, 3080216, 2, 327683, 3080217, 2, 327682, 3080218, 2, 327683, 3080219, 2, 327682, 3080220, 2, 327683, 3080221, 2, 327683, 3080222, 2, 327683, 3080223, 2, 327682, 3080224, 2, 327683, 3080225, 2, 327683, 3080226, 2, 327682, 3080227, 2, 327682, 3080228, 2, 327682, 3080229, 2, 327682, 3080230, 2, 327683, 3080231, 2, 327683, 3080232, 2, 327682, 3080233, 2, 327682, 3080234, 2, 327683, 3080235, 2, 327683, 3080236, 2, 327682, 3080237, 2, 327682, 3080238, 2, 327682, 3080239, 2, 327682, 3080240, 2, 327682, 3080241, 2, 327682, 3080242, 2, 327683, 3080243, 2, 327683, 3080244, 2, 327683, 3080245, 2, 327683, 3080246, 2, 327683, 3080247, 2, 327683, 3080248, 2, 327682, 3080249, 2, 327682, 3080250, 2, 327683, 3080251, 2, 327682, 3080252, 2, 327682, 3080253, 2, 327683, 3080254, 2, 262149, 3080264, 2, 262144, 3080265, 2, 327683, 3080266, 2, 327683, 3080267, 2, 327683, 3080268, 2, 327682, 3080269, 2, 327683, 3080270, 2, 327683, 3080271, 2, 327683, 3080272, 2, 327682, 3080273, 2, 65540, 3080274, 2, 131074, 3080275, 2, 196613, 3211262, 2, 0, 3145809, 2, 262144, 3145810, 2, 327682, 3145811, 2, 262149, 3342468, 2, 0, 3670130, 2, 0, 3735666, 2, 0, 3801202, 2, 0, 3801205, 2, 0, 3866738, 2, 0, 3866741, 2, 0, 3932274, 2, 0, 4063345, 2, 0, 4128881, 2, 0, 4128885, 2, 0, 4194418, 2, 0, 16318470, 2, 0, 16318471, 2, 0, 16318472, 2, 0, 16318476, 2, 0, 16318477, 2, 0, 16318478, 2, 0, 16318479, 2, 0, 16318480, 2, 0, 16318481, 2, 0, 16318527, 2, 0, 16318528, 2, 0, 16318529, 2, 0, 16318530, 2, 0, 16318531, 2, 0, 16318534, 2, 0, 16318535, 2, 0, 16318536, 2, 0, 16318537, 2, 0, 16318542, 2, 0, 16318543, 2, 0, 16318544, 2, 0, 16318545, 2, 0, 16318546, 2, 0, 16384066, 2, 0 )

[node name="TileMap v2" type="TileMap" parent="LevelLayer Z3/Level_00"]
visible = false
tile_set = SubResource( 108 )
cell_size = Vector2( 8, 8 )
format = 1
tile_data = PoolIntArray( 720925, 0, 65548, 720926, 0, 65549, 720927, 0, 65550, 786468, 0, 65544, 786473, 0, 65548, 786474, 0, 131088, 851988, 0, 65542, 851990, 0, 65553, 851992, 0, 65548, 851993, 0, 65549, 851994, 0, 65549, 851995, 0, 65549, 851996, 0, 65549, 851997, 0, 65549, 851998, 0, 65550, 852000, 0, 65548, 852001, 0, 65550, 852004, 0, 393227, 852005, 0, 524303, 852006, 0, 65550, 852011, 0, 786433, 852012, 0, 589835, 852013, 0, 196622, 852016, 0, 65542, 917524, 0, 196614, 917547, 0, 196608, 917548, 0, 851976, 917552, 0, 131083, 983085, 0, 1048578, 983089, 0, 65547, 1048610, 0, 65553, 1048614, 0, 65553, 1048618, 0, 65548, 1048619, 0, 65549, 1048620, 0, 196621, 1048621, 0, 131073, 1048622, 0, 458766, 1048625, 0, 589840, 1114157, 0, 524290, 1114158, 0, 8, 1114161, 0, 720902, 1114162, 0, 589825, 1179667, 0, 983056, 1179692, 0, 65546, 1179694, 0, 393229, 1179695, 0, 3, 1179696, 0, 655364, 1179697, 0, 131073, 1179698, 0, 720897, 1179699, 0, 262158, 1245202, 0, 983054, 1245228, 0, 196614, 1245231, 0, 1114122, 1245232, 0, 196609, 1245233, 0, 1114123, 1310737, 0, 65546, 1310751, 0, 983057, 1376273, 0, 131078, 1376288, 0, 917520, 1376290, 0, 65553, 1376305, 0, 65548, 1376306, 0, 65549, 1376307, 0, 65550, 1441809, 0, 196614, 1441845, 0, 65536, 1441846, 0, 1048587, 1507355, 0, 65542, 1507376, 0, 65553, 1507381, 0, 524301, 1507382, 0, 131073, 1507383, 0, 458766, 1572891, 0, 196614, 1572896, 0, 65553, 1572915, 0, 983057, 1572918, 0, 393222, 1572919, 0, 131074, 1638412, 0, 327691, 1638413, 0, 917509, 1638424, 0, 65551, 1638425, 0, 65550, 1638452, 0, 917517, 1638454, 0, 458763, 1638455, 0, 524302, 1703948, 0, 1245184, 1703950, 0, 786439, 1703951, 0, 65538, 1703955, 0, 1048586, 1703956, 0, 65537, 1703957, 0, 589835, 1703958, 0, 589839, 1703959, 0, 196624, 1703964, 0, 65542, 1703966, 0, 65548, 1703967, 0, 65550, 1703970, 0, 65536, 1703971, 0, 65537, 1703972, 0, 65538, 1703987, 0, 917521, 1703990, 0, 196616, 1769485, 0, 983044, 1769486, 0, 655372, 1769487, 0, 196610, 1769490, 0, 131084, 1769491, 0, 131073, 1769492, 0, 131073, 1769493, 0, 458752, 1769496, 0, 196623, 1769497, 0, 65549, 1769498, 0, 65550, 1769500, 0, 589840, 1769506, 0, 851969, 1769507, 0, 262148, 1769508, 0, 8, 1835027, 0, 1114122, 1835028, 0, 196609, 1835029, 0, 524299, 1835030, 0, 524303, 1835031, 0, 65552, 1835036, 0, 393227, 1835037, 0, 262158, 1835039, 0, 196620, 1835040, 0, 589831, 1835041, 0, 262160, 1835044, 0, 393225, 1835045, 0, 393231, 1835046, 0, 458760, 1835047, 0, 196622, 1835059, 0, 65553, 1835063, 0, 65548, 1835064, 0, 65550, 1900576, 0, 196615, 1900582, 0, 458769, 1966091, 0, 65548, 1966092, 0, 65550, 1966099, 0, 327691, 1966100, 0, 917509, 1966103, 0, 983056, 1966107, 0, 65553, 1966114, 0, 983056, 1966117, 0, 327687, 1966118, 0, 393224, 2031631, 0, 65551, 2031632, 0, 65550, 2031635, 0, 720910, 2031637, 0, 1048584, 2031638, 0, 851985, 2031649, 0, 917521, 2031653, 0, 196616, 2097165, 0, 65548, 2097166, 0, 65552, 2097171, 0, 458759, 2097172, 0, 720913, 2097173, 0, 1114121, 2097209, 0, 327691, 2097210, 0, 196622, 2162704, 0, 65553, 2162707, 0, 196616, 2162710, 0, 131087, 2162711, 0, 65549, 2162712, 0, 65549, 2162713, 0, 65549, 2162714, 0, 65549, 2162715, 0, 65550, 2162720, 0, 65548, 2162721, 0, 65549, 2162722, 0, 65549, 2162723, 0, 65550, 2162745, 0, 983040, 2228235, 0, 65548, 2228236, 0, 65549, 2228237, 0, 65549, 2228238, 0, 65550, 2228280, 0, 917521, 2228282, 0, 917520, 2293780, 0, 983057, 2293785, 0, 1048586, 2293786, 0, 1048587, 2293790, 0, 983056, 2293814, 0, 65553, 2359317, 0, 131087, 2359318, 0, 65549, 2359319, 0, 65549, 2359320, 0, 655375, 2359321, 0, 655372, 2359322, 0, 524299, 2359323, 0, 786449, 2359325, 0, 983054, 2424860, 0, 917516, 2424873, 0, 65548, 2424874, 0, 65549, 2424875, 0, 65549, 2424876, 0, 65549, 2424877, 0, 65550 )

[node name="Shadows" type="ColorRect" parent="LevelLayer Z3"]
visible = false
material = SubResource( 83 )
margin_right = 640.0
margin_bottom = 360.0
rect_min_size = Vector2( 640, 360 )

[node name="Colors" type="ColorRect" parent="LevelLayer Z3"]
visible = false
material = SubResource( 65 )
margin_left = -3.0
margin_top = 36.0
margin_right = 637.0
margin_bottom = 396.0
rect_min_size = Vector2( 640, 360 )

[node name="NeonDust" type="ColorRect" parent="LevelLayer Z3"]
visible = false
material = SubResource( 99 )
margin_left = -133.0
margin_top = -98.0
margin_right = 760.0
margin_bottom = 508.0
rect_min_size = Vector2( 640, 360 )

[node name="JuicyCamera" parent="." instance=ExtResource( 11 )]
visible = false
z_index = 6

[node name="šejderji" type="Node2D" parent="."]
visible = false
position = Vector2( 407.401, 53.2947 )

[node name="v1" type="Sprite" parent="šejderji"]
material = SubResource( 2 )
position = Vector2( 68, 106 )
texture = SubResource( 3 )

[node name="v3" type="Sprite" parent="šejderji"]
material = SubResource( 101 )
position = Vector2( 189, 104 )
texture = SubResource( 102 )

[node name="v4" type="Sprite" parent="šejderji"]
material = SubResource( 104 )
position = Vector2( 70, 172 )
texture = SubResource( 102 )

[node name="v2" type="Sprite" parent="šejderji"]
material = SubResource( 105 )
position = Vector2( 127, 106 )
texture = SubResource( 102 )

[node name="v5" type="Sprite" parent="šejderji"]
material = SubResource( 106 )
position = Vector2( 130, 172 )
texture = SubResource( 102 )

[node name="v6" type="Sprite" parent="šejderji"]
material = SubResource( 18 )
position = Vector2( 191, 172 )
texture = SubResource( 102 )

[node name="v7 hor" type="Sprite" parent="šejderji"]
material = SubResource( 22 )
position = Vector2( 71, 234 )
texture = SubResource( 102 )

[node name="v7 hor2" type="Sprite" parent="šejderji"]
material = SubResource( 24 )
position = Vector2( 132, 234 )
texture = SubResource( 102 )

[node name="v7 hor3" type="Sprite" parent="šejderji"]
material = SubResource( 20 )
position = Vector2( 194, 234 )
texture = SubResource( 102 )

[node name="neon light" type="Sprite" parent="šejderji"]
material = SubResource( 97 )
position = Vector2( -36.401, 197.705 )
texture = ExtResource( 12 )

[editable path="BodiesLayer Z2/Player"]
