[gd_scene load_steps=69 format=3 uid="uid://dt0v057qrxtdx"]

[ext_resource type="Script" path="res://arena/Arena.gd" id="1"]
[ext_resource type="PackedScene" path="res://player/Player.tscn" id="2"]
[ext_resource type="Texture2D" uid="uid://cnkh5u00asnbk" path="res://resources/graphics/light.png" id="5"]
[ext_resource type="Texture2D" uid="uid://bdg3vsycbjttn" path="res://resources/graphics/bolt.png" id="7"]
[ext_resource type="Script" path="res://arena/BodiesLayer.gd" id="8"]
[ext_resource type="Script" path="res://arena/Effects.gd" id="9"]
[ext_resource type="Texture2D" uid="uid://cg3na0qb77yw4" path="res://resources/graphics/tileset_arena_v2.png" id="10"]
[ext_resource type="PackedScene" path="res://gameview/JuicyCamera.tscn" id="11"]
[ext_resource type="Texture2D" uid="uid://tlh2dr2k7lgm" path="res://resources/graphics/tileset_arena.png" id="12"]
[ext_resource type="Script" path="res://arena/FejkPlejer.gd" id="13"]
[ext_resource type="Script" path="res://LevelLayer Z3.gd" id="15"]
[ext_resource type="Script" path="res://BackgroundLayer Z0.gd" id="17"]
[ext_resource type="Script" path="res://EffectsLayer Z1.gd" id="18"]

[sub_resource type="Shader" id="126"]
code = "shader_type canvas_item;
render_mode blend_add;

uniform sampler2D noise_texture;
uniform float speed1 = 0.02;
uniform float speed2 = 0.05;
uniform float threshold_min = 0.5;
uniform float threshold_max = 0.58;

uniform float noise_resolution_x = 64.0;
uniform float noise_resolution_y = 360.0;

float random (vec2 st) {
    return fract(sin(dot(st.xy,
                         vec2(12.9898,78.233)))*
        43758.5453123);
}

void fragment() {
	
	vec4 col0 = texture(noise_texture, mod(UV + TIME * speed1, vec2(1, 1)));
	vec4 col1 = texture(noise_texture, mod(UV + TIME * speed2, vec2(1, 1)));
	
	//we apply red channel as alpha
	col0.a = col0.r;
	col1.a = col1.r;
	
	//step function return 0 if last parameter is < threshold and 1 otherwise
	//here we want 1 if value between threshold_min and threshold_max
	//same result as following code:
	/*
	float col = (col0. r + col1.r) / 2.0;
	if(col > threshold_min && col < threshold_max){
		COLOR = vec4(1.0, 1.0, 1.0, 1.0);
	} else {
		COLOR = vec4(1.0, 1.0, 1.0, 0.0);
	}
	*/
	vec4 water_color;
	vec4 pixelated_color;
	
	//here we normalize col0 + col1 (/ 2.0) to have result between [0,1]
	water_color = step(threshold_min, (col0 + col1) / 2.0) * (1.0 - step(threshold_max, (col0 + col1) / 2.0));
	
	
	//as UV is between [0;1] we multiply with noise_resolution factor to have noise_resolution differents values
//	float val = random(floor(UV * noise_resolution_x));
//	pixelated_color = vec4(val,val,val,1.0);
//	COLOR =  mix(pixelated_color, water_color, 0.5);
	
	COLOR = water_color;
}"

[sub_resource type="FastNoiseLite" id="115"]
seed = 2

[sub_resource type="NoiseTexture2D" id="116"]
width = 640
height = 320
seamless = true
noise = SubResource("115")

[sub_resource type="ShaderMaterial" id="114"]
shader = SubResource("126")
shader_parameter/speed1 = 0.0
shader_parameter/speed2 = 0.01
shader_parameter/threshold_min = 0.495
shader_parameter/threshold_max = 0.533
shader_parameter/noise_resolution_x = 640.0
shader_parameter/noise_resolution_y = 360.0
shader_parameter/noise_texture = SubResource("116")

[sub_resource type="Shader" id="87"]
code = "shader_type canvas_item;
//render_mode blend_premul_alpha; // nč bolš

//blend_mix - Mix blend mode (alpha is transparency), default.
//blend_add - Additive blend mode.
//blend_sub - Subtractive blend mode.
//blend_mul - Multiplicative blend mode.
//blend_premul_alpha - Pre-multiplied alpha blend mode.
//blend_disabled - Disable blending, values (including alpha) are written as-is.
//unshaded - Result is just albedo. No lighting/shading happens in material.
//light_only - Only draw on light pass
//skip_vertex_transform - VERTEX/NORMAL/etc need to be transformed manually in vertex function.



// šejder v1 - prepoznava 100% transparenco in aplicira novo barvo na te pixle
// šejder v2 - prepoznava tudi cutout barvo, ki jo potem manipulira
// šejder v3 - prepoznava barvo, ki ji mora dodat senco
// šejder v4 - prepoznava različne barve, ki jim dodaj različne sence
// šejder v5 - dodaja sence za prizemljene objekte

//... simple nadgradnja je če dodam več barv za manipulirat ... al pa celo gradient

// barve
uniform vec4 manipulate_color : hint_color = vec4(1.0, 0.0, 0.0, 1.0); // select color to regirster and manipulate
uniform bool manipulate_other_colors = true;
uniform vec4 transparent_to_color : hint_color = vec4(0.0, 0.0, 0.0, 0.0); // apply color to texture with alpha 0.0

// shadow
uniform vec4 shadow_color : hint_color = vec4(0.0, 0.0, 0.0, 1.0);
uniform float shadow_offset_x = 1.0; // smer offseta ... to niso texli ampak pixli
uniform float shadow_offset_y = 1.0; // smer offseta ... to niso texli ampak pixli
uniform float texture_altitude = 5.0; // količina offseta ... višin texture

// dimenzija teksture za uskladitev texlov s pixli (1/texture original size)  
uniform float texture_width = 640.0;
uniform float texture_height = 360.0;



void fragment(){

	// preračun pravge offseta sence ... pixle konvertamo v texle
	vec2 shadow_offset = vec2(shadow_offset_x / texture_width, shadow_offset_y / texture_height);
	vec2 uvs = UV + shadow_offset * texture_altitude;
	
	// poberemo prikaz texture in apliciramo samo offset še predno apliciramo barvo 
	vec4 color = texture(TEXTURE, uvs);

	
	// manipuliramo izbrano barvo
	if (manipulate_other_colors == false){
		
		// če je barva texture enaka izbrani apliciramo efekt
		if (color == manipulate_color){
			color = shadow_color * color.a;
		}
		// druge barve so brez efekta
		else {
			color.a = 0.0; // 100% transparenca
			color = texture(TEXTURE, UV); // original barva in pozicija
		}
	}
	
	// manipuliramo vse razen izbrane barve
	else if (manipulate_other_colors == true){
		
		// če barva texture ni transparenta apliciramo efekt
		if (color.a > 0.0){
			
			// barva enaka izbrani barvi je brez efekta
			if (color == manipulate_color){
				color.a = 0.0;
				color = texture(TEXTURE, UV);
			}
			// aplciramo efekt na vse druge barve
			else {
				color = shadow_color * color.a;
			}
		}
		// barva transparentnega dela tekture
		else {
			color = transparent_to_color;
		}
		
	}
	
	COLOR = color;
}"

[sub_resource type="ShaderMaterial" id="88"]
shader = SubResource("87")

[sub_resource type="ViewportTexture" id="92"]
viewport_path = NodePath("EffectsLayer Z1/Viewport")

[sub_resource type="Shader" id="85"]
code = "shader_type canvas_item;
render_mode blend_premul_alpha;

//blen


void fragment(){

	COLOR =  texture(TEXTURE, UV);
}"

[sub_resource type="ShaderMaterial" id="86"]
shader = SubResource("85")

[sub_resource type="ViewportTexture" id="93"]
viewport_path = NodePath("EffectsLayer Z1/Viewport")

[sub_resource type="Animation" id="112"]
resource_name = "shield_on"
length = 1.4
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath(".:scale")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0, 0.8, 1.4),
"transitions": PackedFloat32Array(0.5, -2, -2),
"update": 0,
"values": [Vector2(0, 0), Vector2(0.6, 0.6), Vector2(0.5, 0.5)]
}
tracks/1/type = "value"
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/path = NodePath(".:modulate")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/keys = {
"times": PackedFloat32Array(0, 0.5, 1.4),
"transitions": PackedFloat32Array(1, 1, 1),
"update": 0,
"values": [Color(1, 1, 1, 0), Color(1, 1, 1, 0), Color(1, 1, 1, 0.313726)]
}

[sub_resource type="Animation" id="110"]
resource_name = "shielding"
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath(".:scale")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0, 0.5, 1),
"transitions": PackedFloat32Array(-2, -2, -2),
"update": 0,
"values": [Vector2(0.5, 0.5), Vector2(0.6, 0.6), Vector2(0.5, 0.5)]
}

[sub_resource type="AnimationLibrary" id="AnimationLibrary_g6pnq"]
_data = {
"shield_on": SubResource("112"),
"shielding": SubResource("110")
}

[sub_resource type="Animation" id="Animation_mno8p"]
resource_name = "shield_on"
tracks/0/type = "value"
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/path = NodePath(".:scale")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/keys = {
"times": PackedFloat32Array(0, 0.5, 0.8),
"transitions": PackedFloat32Array(1, 0.435275, -2),
"update": 0,
"values": [Vector2(0, 0), Vector2(0.7, 0.7), Vector2(0.5, 0.5)]
}
tracks/1/type = "value"
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/path = NodePath(".:modulate")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/keys = {
"times": PackedFloat32Array(0.2, 0.8),
"transitions": PackedFloat32Array(1, 1),
"update": 0,
"values": [Color(1, 1, 1, 0), Color(1, 1, 1, 1)]
}

[sub_resource type="AnimationLibrary" id="AnimationLibrary_3ajql"]
_data = {
"shield_on": SubResource("Animation_mno8p"),
"shielding": SubResource("110")
}

[sub_resource type="Shader" id="61"]
code = "shader_type canvas_item;
render_mode blend_mix;

// šejder v1 - prepoznava 100% transparenco in aplicira novo barvo na te pixle
// šejder v2 - prepoznava tudi cutout barvo, ki jo potem manipulira
// šejder v3 - prepoznava barvo, ki ji mora dodat senco
// šejder v4 - prepoznava različne barve, ki jim dodaj različne sence
// šejder v5 - dodaja sence za prizemljene objekte

//... simple nadgradnja je če dodam več barv za manipulirat ... al pa celo gradient

// barve
uniform vec4 manipulate_color : hint_color = vec4(1.0, 0.0, 0.0, 1.0); // select color to regirster and manipulate
uniform bool manipulate_other_colors = true;
uniform vec4 transparent_color : hint_color = vec4(0.0, 0.0, 0.0, 0.0); // apply color to texture with alpha 0.0
uniform vec4 transparent_new_color : hint_color = vec4(0.0, 0.0, 0.0, 0.0); // apply color to texture with alpha 0.0

// shadow
uniform vec4 shadow_color : hint_color = vec4(0.0, 0.0, 0.0, 1.0);
uniform float shadow_offset_x = 1.0; // smer offseta ... to niso texli ampak pixli
uniform float shadow_offset_y = 1.0; // smer offseta ... to niso texli ampak pixli
uniform float texture_altitude = 5.0; // količina offseta ... višin texture

// dimenzija teksture za uskladitev texlov s pixli (1/texture original size)  
uniform float texture_width = 640.0;
uniform float texture_height = 360.0;



void fragment(){

	// preračun pravge offseta sence ... pixle konvertamo v texle
	vec2 shadow_offset = vec2(shadow_offset_x / texture_width, shadow_offset_y / texture_height);
	vec2 uvs = SCREEN_UV + shadow_offset * texture_altitude;
	
	// poberemo prikaz texture in apliciramo samo offset še predno apliciramo barvo 
	vec4 color = texture(SCREEN_TEXTURE, uvs);

	
	// manipuliramo izbrano barvo
	if (manipulate_other_colors == false){
		
		// če je barva texture enaka izbrani apliciramo efekt
		if (color == manipulate_color){
			color = shadow_color * color.a;
		}
		// druge barve so brez efekta
		else {
			color.a = 0.0; // 100% transparenca
			color = texture(SCREEN_TEXTURE, SCREEN_UV); // original barva in pozicija
		}
	}
	
	// manipuliramo vse razen izbrane barve
	else if (manipulate_other_colors == true){
		
		// če barva texture ni transparenta apliciramo efekt
		if (color == transparent_color){
//		if (color.a > 0.0){
			
			// barva enaka izbrani barvi je brez efekta
			if (color == manipulate_color){
				color.a = 0.0;
				color = texture(SCREEN_TEXTURE, SCREEN_UV);
			}
			// aplciramo efekt na vse druge barve
			else {
				color = shadow_color * color.a;
			}
		}
		// barva transparentnega dela tekture
		else {
			color = transparent_new_color;
		}
		
	}
	
	COLOR = color;
}"

[sub_resource type="ShaderMaterial" id="63"]
shader = SubResource("61")

[sub_resource type="Shader" id="74"]
code = "shader_type canvas_item;
render_mode blend_mix;

// šejder v1 - prepoznava 100% transparenco in aplicira novo barvo na te pixle
// šejder v2 - prepoznava tudi cutout barvo, ki jo potem manipulira
// šejder v3 - prepoznava barvo, ki ji mora dodat senco
// šejder v4 - prepoznava različne barve, ki jim dodaj različne sence
// šejder v5 - dodaja sence za prizemljene objekte

//... simple nadgradnja je če dodam več barv za manipulirat ... al pa celo gradient

// barve
uniform vec4 manipulate_color_1 : hint_color = vec4(1.0, 0.0, 0.0, 1.0); // select color to regirster and manipulate
uniform vec4 new_color_1 : hint_color = vec4(1.0, 1.0, 0.0, 1.0); // select color to regirster and manipulate
uniform vec4 manipulate_color_2 : hint_color = vec4(0.0, 1.0, 0.0, 1.0); // select color to regirster and manipulate
uniform vec4 new_color_2 : hint_color = vec4(0.0, 1.0, 1.0, 1.0); // select color to regirster and manipulate
uniform vec4 manipulate_color_3 : hint_color = vec4(0.0, 0.0, 1.0, 1.0); // select color to regirster and manipulate
uniform vec4 new_color_3 : hint_color = vec4(1.0, 0.0, 1.0, 1.0); // select color to regirster and manipulate

uniform bool manipulate_other = false;
uniform vec4 new_color_other : hint_color = vec4(0.5, 0.5, 0.5, 1.0); // select color to regirster and manipulate

uniform vec4 transparent_to_color : hint_color = vec4(0.0, 0.0, 0.0, 0.0); // apply color to texture with alpha 0.0
uniform vec4 transparent_color : hint_color = vec4(0.0, 0.0, 0.0, 0.0); // apply color to texture with alpha 0.0


void fragment(){

	// poberemo prikaz texture in apliciramo samo offset še predno apliciramo barvo 
	vec4 color = texture(SCREEN_TEXTURE, SCREEN_UV);

	
	// manipuliramo izbrane barve
	if (manipulate_other == false){
		
		// če je barva texture enaka izbrani apliciramo novo (s transparenco)
		if (color == manipulate_color_1 ){
			color = new_color_1 * color.a;
		}
		else if (color.rgb == manipulate_color_2.rgb){
			color.rgb = new_color_2.bgr;
			
			float white_level = 0.5; 
			color.rgb = vec3(white_level);
			color.a = white_level
		
		}
		else if (color == manipulate_color_3){
			color = new_color_3 * color.a;
		}
		
		// druge barve so brez efekta
		else {
			color.a = 0.0; // 100% transparenca
//			color = texture(TEXTURE, UV); // original barva in pozicija
		}
	}
	
	// manipuliramo vse druge barve
	else if (manipulate_other == true){
		
		// če barva texture ni transparenta apliciramo efekt
		if (color.a > 0.0){
			
			// barva enaka izbrani barvi je brez efekta
			if (color == manipulate_color_1){
				color.a = 0.0;
			}
			else if (color == manipulate_color_2){
				color.a = 0.0;
			}
			else if (color == manipulate_color_3){
				color.a = 0.0;
			}
			
			// aplciramo prvo barve efekt na vse druge barve
			else {
				color = new_color_other * color.a;
			}
		}
		// barva transparentnega dela tekture
		else {
			color = transparent_to_color;
		}
		
	}
	
	COLOR = color;
}"

[sub_resource type="ShaderMaterial" id="16"]
shader = SubResource("74")

[sub_resource type="Shader" id="415"]
code = "shader_type canvas_item;

// šejder v1 - prepoznava 100% transparenco in aplicira novo barvo na te pixle
// šejder v2 - prepoznava tudi cutout barvo, ki jo potem manipulira
// šejder v3 - prepoznava barvo, ki ji mora dodat senco
// šejder v4 - prepoznava različne barve, ki jim dodaj različne sence
// šejder v5 - dodaja sence za prizemljene objekte

//... simple nadgradnja je če dodam več barv za manipulirat ... al pa celo gradient

// barve
uniform vec4 manipulate_color_1 : hint_color = vec4(1.0, 0.0, 0.0, 1.0); // select color to regirster and manipulate
uniform vec4 new_color_1 : hint_color = vec4(1.0, 1.0, 0.0, 1.0); // select color to regirster and manipulate
uniform vec4 manipulate_color_2 : hint_color = vec4(0.0, 1.0, 0.0, 1.0); // select color to regirster and manipulate
uniform vec4 new_color_2 : hint_color = vec4(0.0, 1.0, 1.0, 1.0); // select color to regirster and manipulate
uniform vec4 manipulate_color_3 : hint_color = vec4(0.0, 0.0, 1.0, 1.0); // select color to regirster and manipulate
uniform vec4 new_color_3 : hint_color = vec4(1.0, 0.0, 1.0, 1.0); // select color to regirster and manipulate

uniform bool manipulate_other = false;
uniform vec4 new_color_other : hint_color = vec4(0.5, 0.5, 0.5, 1.0); // select color to regirster and manipulate

uniform vec4 transparent_to_color : hint_color = vec4(0.0, 0.0, 0.0, 0.0); // apply color to texture with alpha 0.0


void fragment(){

	// poberemo prikaz texture in apliciramo samo offset še predno apliciramo barvo 
	vec4 color = texture(TEXTURE, UV);

	
	// manipuliramo izbrane barve
	if (manipulate_other == false){
		
		// če je barva texture enaka izbrani apliciramo novo (s transparenco)
		if (color == manipulate_color_1 ){
			color = new_color_1 * color.a;
		}
		else if (color == manipulate_color_2){
			color = new_color_2 * color.a;
		}
		else if (color == manipulate_color_3){
			color = new_color_3 * color.a;
		}
		
		// druge barve so brez efekta
		else {
			color.a = 0.0; // 100% transparenca
//			color = texture(TEXTURE, UV); // original barva in pozicija
		}
	}
	
	// manipuliramo vse druge barve
	else if (manipulate_other == true){
		
		// če barva texture ni transparenta apliciramo efekt
		if (color.a > 0.0){
			
			// barva enaka izbrani barvi je brez efekta
			if (color == manipulate_color_1){
				color.a = 0.0;
			}
			else if (color == manipulate_color_2){
				color.a = 0.0;
			}
			else if (color == manipulate_color_3){
				color.a = 0.0;
			}
			
			// aplciramo prvo barve efekt na vse druge barve
			else {
				color = new_color_other * color.a;
			}
		}
		// barva transparentnega dela tekture
		else {
			color = transparent_to_color;
		}
		
	}
	
	COLOR = color;
}"

[sub_resource type="ShaderMaterial" id="416"]
shader = SubResource("415")

[sub_resource type="TileSetAtlasSource" id="TileSetAtlasSource_tfi7u"]
texture = ExtResource("10")

[sub_resource type="TileSet" id="108"]
sources/0 = SubResource("TileSetAtlasSource_tfi7u")

[sub_resource type="Shader" id="82"]
code = "shader_type canvas_item;

// šejder v1 - prepoznava 100% transparenco in aplicira novo barvo na te pixle
// šejder v2 - prepoznava tudi cutout barvo, ki jo potem manipulira
// šejder v3 - prepoznava barvo, ki ji mora dodat senco
// šejder v4 - prepoznava različne barve, ki jim dodaj različne sence
// šejder v5 - dodaja sence za prizemljene objekte

//... simple nadgradnja je če dodam več barv za manipulirat ... al pa celo gradient

// barve
uniform vec4 manipulate_color : hint_color = vec4(1.0, 0.0, 0.0, 1.0); // select color to regirster and manipulate
uniform vec4 manipulate_high_color : hint_color = vec4(1.0, 1.0, 1.0, 1.0); // select color to regirster and manipulate
uniform bool manipulate_other_colors = true;
uniform vec4 transparent_color : hint_color = vec4(0.0, 0.0, 0.0, 0.0); // apply color to texture with alpha 0.0
uniform vec4 transparent_new_color : hint_color = vec4(0.0, 0.0, 0.0, 0.0); // apply color to texture with alpha 0.0

// shadow
uniform vec4 shadow_color : hint_color = vec4(0.0, 0.0, 0.0, 1.0);
uniform float shadow_offset_x = 1.0; // smer offseta ... to niso texli ampak pixli
uniform float shadow_offset_y = 1.0; // smer offseta ... to niso texli ampak pixli
uniform float texture_altitude = 5.0; // količina offseta ... višin texture

// dimenzija teksture za uskladitev texlov s pixli (1/texture original size)  
uniform float texture_width = 640.0;
uniform float texture_height = 360.0;



void fragment(){

	// preračun pravge offseta sence ... pixle konvertamo v texle
	vec2 shadow_offset = vec2(shadow_offset_x / texture_width, shadow_offset_y / texture_height);
	vec2 uvs = SCREEN_UV + shadow_offset * texture_altitude;
	
	// poberemo prikaz texture in apliciramo samo offset še predno apliciramo barvo 
	vec4 color = texture(SCREEN_TEXTURE, uvs);

	
	// manipuliramo izbrano barvo
	if (manipulate_other_colors == false){
		
		// če je barva texture enaka izbrani apliciramo efekt
		if (color == manipulate_color){
			color = shadow_color * color.a;
		}
		else if (color == manipulate_high_color){
			color = vec4(1.0, 1.0, 1.0, 1.0) ;
			
		}
		// druge barve so brez efekta
		else {
			color.a = 0.0; // 100% transparenca
			color = texture(SCREEN_TEXTURE, SCREEN_UV); // original barva in pozicija
		}
	}
	
	// manipuliramo vse razen izbrane barve
	else if (manipulate_other_colors == true){
		
		// če barva texture ni transparenta apliciramo efekt
		if (color == transparent_color){
//		if (color.a > 0.0){
			
			// barva enaka izbrani barvi je brez efekta
			if (color == manipulate_color){
				color.a = 0.0;
				color = texture(SCREEN_TEXTURE, SCREEN_UV);
			}
			// aplciramo efekt na vse druge barve
			else {
				color = shadow_color * color.a;
			}
		}
		// barva transparentnega dela tekture
		else {
			color = transparent_new_color;
		}
		
	}
	
	COLOR = color;
}"

[sub_resource type="ShaderMaterial" id="83"]
shader = SubResource("82")

[sub_resource type="Shader" id="64"]
code = "shader_type canvas_item;

// šejder v1 - prepoznava 100% transparenco in aplicira novo barvo na te pixle
// šejder v2 - prepoznava tudi cutout barvo, ki jo potem manipulira
// šejder v3 - prepoznava barvo, ki ji mora dodat senco
// šejder v4 - prepoznava različne barve, ki jim dodaj različne sence
// šejder v5 - dodaja sence za prizemljene objekte

//... simple nadgradnja je če dodam več barv za manipulirat ... al pa celo gradient

// barve
uniform vec4 manipulate_color_1 : hint_color = vec4(1.0, 0.0, 0.0, 1.0); // select color to regirster and manipulate
uniform vec4 new_color_1 : hint_color = vec4(1.0, 1.0, 0.0, 1.0); // select color to regirster and manipulate
uniform vec4 manipulate_color_2 : hint_color = vec4(0.0, 1.0, 0.0, 1.0); // select color to regirster and manipulate
uniform vec4 new_color_2 : hint_color = vec4(0.0, 1.0, 1.0, 1.0); // select color to regirster and manipulate
uniform vec4 manipulate_color_3 : hint_color = vec4(0.0, 0.0, 1.0, 1.0); // select color to regirster and manipulate
uniform vec4 new_color_3 : hint_color = vec4(1.0, 0.0, 1.0, 1.0); // select color to regirster and manipulate

uniform bool manipulate_other = false;
uniform vec4 new_color_other : hint_color = vec4(0.5, 0.5, 0.5, 1.0); // select color to regirster and manipulate

uniform vec4 transparent_to_color : hint_color = vec4(0.0, 0.0, 0.0, 0.0); // apply color to texture with alpha 0.0


void fragment(){

	// poberemo prikaz texture in apliciramo samo offset še predno apliciramo barvo 
	vec4 color = texture(SCREEN_TEXTURE, SCREEN_UV);

	
	// manipuliramo izbrane barve
	if (manipulate_other == false){
		
		// če je barva texture enaka izbrani apliciramo novo (s transparenco)
		if (color == manipulate_color_1 ){
			color = new_color_1 * color.a;
		}
		else if (color == manipulate_color_2){
			color = new_color_2 * color.a;
		}
		else if (color == manipulate_color_3){
			color = new_color_3 * color.a;
		}
		
		// druge barve so brez efekta
		else {
			color.a = 0.0; // 100% transparenca
//			color = texture(TEXTURE, UV); // original barva in pozicija
		}
	}
	
	// manipuliramo vse druge barve
	else if (manipulate_other == true){
		
		// če barva texture ni transparenta apliciramo efekt
		if (color.a > 0.0){
			
			// barva enaka izbrani barvi je brez efekta
			if (color == manipulate_color_1){
				color.a = 0.0;
			}
			else if (color == manipulate_color_2){
				color.a = 0.0;
			}
			else if (color == manipulate_color_3){
				color.a = 0.0;
			}
			
			// aplciramo prvo barve efekt na vse druge barve
			else {
				color = new_color_other * color.a;
			}
		}
		// barva transparentnega dela tekture
		else {
			color = transparent_to_color;
		}
		
	}
	
	COLOR = color;
}"

[sub_resource type="ShaderMaterial" id="65"]
shader = SubResource("64")

[sub_resource type="Shader" id="413"]
code = "shader_type canvas_item;

uniform vec4 color1 : hint_color;
uniform vec4 color2 : hint_color;
uniform float threshold;
uniform float intensity;
uniform float opacity;
uniform vec4 glow_color : hint_color;

void fragment() {
	// Get the pixel color from the texture
	vec4 pixel_color = texture(SCREEN_TEXTURE, SCREEN_UV);
	
	// Calculate the distance between the pixel color and the first source color
	float distance = length(pixel_color - color1);
	
	// Calculate the distance between the pixel color and the second source color
	float distance_second = length(pixel_color - color2);
	
	// Create a new variable to store the modified glow color
	vec4 modified_glow_color = glow_color;
	
	// Set the alpha value of the modified glow color to the specified opacity
	modified_glow_color.a = opacity;
	
	// If the distance to either source color is below the threshold, set the output color to a blend of the pixel color and the modified glow color
	if (distance < threshold || distance_second < threshold) {
		COLOR = mix(pixel_color, modified_glow_color * intensity, modified_glow_color.a);
	}
	// Otherwise, set the output color to the pixel color
	else {
		COLOR = pixel_color;
	}
}"

[sub_resource type="ShaderMaterial" id="414"]
shader = SubResource("413")

[sub_resource type="Shader" id="98"]
code = "shader_type canvas_item;

// Donut Mask
uniform vec2 DonutMaskCenter = vec2(0.5);
uniform float DonutMaskSize = 0.5;
uniform float DonutMaskThickness = 0.15;

// Outline
uniform float OutlineWidth : hint_range(0.0, 64) = 3.0;
uniform float OutlinePixelSize : hint_range(0.01, 10.0) = 1;

// Rainbow
uniform bool UseRainbowColorOutline = true;
uniform float RainbowColorLightOffset : hint_range(0.0, 1.0) = 0.5;   // this offsets all color channels; if set to 0 only red green and blue colors will be shown.
uniform float RainbowColorSinFrequency : hint_range(0.1, 2.0) = 0.1;  // frequency of the rainbow

// Noise
uniform bool OutlineUseNoise = false;
uniform float NoiseBlockSize = 5.0;
uniform float NoiseMaxLineWidth = 10.0;
uniform float NoiseMinLineWidth = 5.0;
uniform float NoiseFreq = 1.0;

uniform vec4 BackgroundColor : hint_color = vec4(0.95, 0.95, 0.95, 1.0);

// Noise Constants
const float PI = 3.1415;
const int ANGLE_RESOLUTION = 16;
const int GRADIENT_RESOLUTION = 8;

// Mmmm donuts
float createDonutMask(
	vec2 inputTexturePixelSize,
	vec2 inputUV) {
	float ratio = inputTexturePixelSize.x / inputTexturePixelSize.y;
	vec2 scaledUV = (inputUV - vec2(DonutMaskCenter.x, 0.0)) / vec2(ratio, 1.0) + vec2(DonutMaskCenter.x, 0.0);
	return (1.0 - smoothstep(DonutMaskSize - 0.2, DonutMaskSize, length(scaledUV - DonutMaskCenter))) *
		smoothstep(DonutMaskSize - DonutMaskThickness - 0.1, 
		DonutMaskSize - DonutMaskThickness, length(scaledUV - DonutMaskCenter)
	);
}

vec4 createRainbowColor(float t) {
	return vec4(RainbowColorLightOffset + sin(2.0*3.14*RainbowColorSinFrequency*t),
							   RainbowColorLightOffset + sin(2.0*3.14*RainbowColorSinFrequency*t + radians(120.0)),
							   RainbowColorLightOffset + sin(2.0*3.14*RainbowColorSinFrequency*t + radians(240.0)),
							   1.0);
}

vec4 handleInline(vec4 finalPixelColor, vec4 outlineColor, vec4 originalPixelColor) {
	// Handle inline
    if (finalPixelColor.r < BackgroundColor.r || finalPixelColor.g < BackgroundColor.g || finalPixelColor.b < BackgroundColor.b) {
        finalPixelColor.rgb = mix(outlineColor.rgb, finalPixelColor.rgb, 1.0 - tanh(3.0*originalPixelColor.b));
    }
	
	return finalPixelColor;
}

float hash(vec2 p, float s) {
	return fract(35.1 * sin(dot(vec3(112.3, 459.2, 753.2), vec3(p, s))));
}

float noise(vec2 p, float s) {
	vec2 d = vec2(0, 1);
	vec2 b = floor(p);
	vec2 f = fract(p);
	return mix(
		mix(hash(b + d.xx, s), hash(b + d.yx, s), f.x),
		mix(hash(b + d.xy, s), hash(b + d.yy, s), f.x), f.y);
}

float getLineWidth(vec2 p, float s) {
	p /= NoiseBlockSize;
	float w = 0.0;
	float intensity = 1.0;
	for (int i = 0; i < 3; i++) {
		w = mix(w, noise(p, s), intensity);
		p /= 2.0;
		intensity /= 2.0;
	}
	
	return mix(NoiseMaxLineWidth, NoiseMinLineWidth, w);
}

bool pixelInRange(sampler2D text, vec2 uv, vec2 dist) {
	float alpha = 0.0;
	for (int i = 0; i < ANGLE_RESOLUTION; i++) {
		float angle = 2.0 * PI * float(i) / float(ANGLE_RESOLUTION);
		vec2 disp = dist * vec2(cos(angle), sin(angle));
		if (texture(text, uv + disp).b < 0.5) return true;
	}
	return false;
}

float getClosestDistance(sampler2D text, vec2 uv, vec2 maxDist) {
	if (!pixelInRange(text, uv, maxDist)) return -1.0;
	
	float hi = 1.0; float lo = 0.0;
	
	for (int i = 1; i <= GRADIENT_RESOLUTION; i++) {
		float curr = (hi + lo) / 2.0;
		if (pixelInRange(text, uv, curr * maxDist)) {
			hi = curr;
		}
		else {
			lo = curr;
		}
	}
	return hi;
	
}

vec4 handleNoise(
	vec4 finalPixelColor, 
	float t,  
	vec2 pixelSize,
	sampler2D inputTexture,
	vec2 inputUV,
	vec4 originalPixelColor) {
		
	float timeStep = floor(NoiseFreq * t);
	vec2 scaledDistance = pixelSize * getLineWidth(inputUV / pixelSize, timeStep);
	float weight = getClosestDistance(inputTexture, inputUV, scaledDistance);
	
	if ( weight > 0.0) {
	    finalPixelColor.a = mix(0.0, finalPixelColor.a, tanh(5.0*weight));
	} else {
		finalPixelColor = originalPixelColor;
	}
	
	return finalPixelColor;
}

vec4 handleOutline(vec4 finalPixelColor, 
					vec4 outlineColor, 
					vec4 originalPixelColor, 
					sampler2D inputTexture, 
					vec2 inputUV) {
	if (finalPixelColor.r > 0.05 || finalPixelColor.g > 0.05 || finalPixelColor.b > 0.05) {
		vec2 unit = (OutlinePixelSize ) / vec2(textureSize(inputTexture, 0));
		
        finalPixelColor.rgb = mix(outlineColor.rgb, finalPixelColor.rgb, 1.0 - tanh(3.0*originalPixelColor.b));
		finalPixelColor.a = 0.0;

        for (float x = -ceil(OutlineWidth); x <= ceil(OutlineWidth); x++) {
            for (float y = -ceil(OutlineWidth); y <= ceil(OutlineWidth); y++) {
				vec4 current_texture = texture(inputTexture, inputUV + vec2(x*unit.x, y*unit.y));
                if (current_texture.r > 0.5 || current_texture.g > 0.5 || current_texture.b > 0.5 || (x==0.0 && y==0.0)) {
                    continue;
                }
                finalPixelColor.a += outlineColor.a / (pow(x,2)+pow(y,2)) * (1.0-pow(2.0, -OutlineWidth));
				if (finalPixelColor.a > 1.0) {
					finalPixelColor.a = 1.0;
				}
            }
        }
    }
	
	return finalPixelColor;
}

void fragment() {
	float mask = createDonutMask(
		TEXTURE_PIXEL_SIZE,
		UV);
		
	vec4 outlineColor = vec4(1.0, 0.0, 0.0, 1.0);
	if (UseRainbowColorOutline){
		outlineColor = createRainbowColor(TIME);
	}
	
	vec4 finalPixelColor = texture(SCREEN_TEXTURE, SCREEN_UV);
	vec4 originalPixelColor = finalPixelColor;
	
	finalPixelColor = handleInline(finalPixelColor, outlineColor, originalPixelColor);
	finalPixelColor = handleOutline(finalPixelColor, 
		outlineColor,
		originalPixelColor,
		SCREEN_TEXTURE, 
		SCREEN_UV);
	
	finalPixelColor.a = finalPixelColor.a * mask;
	
	if (OutlineUseNoise) {
		finalPixelColor = handleNoise(
			finalPixelColor, 
			TIME,  
			SCREEN_PIXEL_SIZE,
			SCREEN_TEXTURE,
			SCREEN_UV,
			originalPixelColor);
	}
	
	COLOR = finalPixelColor;
}"

[sub_resource type="ShaderMaterial" id="99"]
shader = SubResource("98")

[sub_resource type="Shader" id="4"]
code = "shader_type canvas_item;

uniform float intensity = 0.5f;
uniform float layers = 5.0f;
uniform float speed = 4.0f;

float gradient(vec2 uv){
	
	// čekiramo razdaljo od centra sprajta do koordinate trenutne pike
	return (0.5f - distance(vec2(uv.x, uv.y), vec2(0.5f, 0.5f))); // nastane krog, ker je razdalja od centra konstantna
	
	
}
void fragment(){
	vec4 bg = texture(TEXTURE, UV - TIME/speed); // tukjaj je že notri premikanje
	
	COLOR = bg;
	COLOR.r = gradient(UV); // red kanal damo rezultat gradient funkcije 
	
	// množimo oz. združimo red channel z intensity in teksturo noisa
	COLOR.r = clamp(COLOR.r * bg.r * intensity * 10.0f, 0.0f, 1.0f); // klempam, da ne gre pod nulo in ne nad ena (ker je to barvni kanal)
	//	current color * intensity
	
	
	
	
}"

[sub_resource type="ShaderMaterial" id="2"]
shader = SubResource("4")
shader_parameter/intensity = 0.5
shader_parameter/layers = 5.0
shader_parameter/speed = 4.0

[sub_resource type="FastNoiseLite" id="100"]

[sub_resource type="NoiseTexture2D" id="3"]
width = 48
height = 48
seamless = true
noise = SubResource("100")

[sub_resource type="Shader" id="11"]
code = "shader_type canvas_item;
render_mode blend_mix ;

uniform float intensity = 0.5f;
uniform float layers = 5.0f;
uniform float speed = 4.0f;

float gradient(vec2 uv){
	
	// čekiramo razdaljo od centra sprajta do koordinate trenutne pike
	return (0.5f - distance(vec2(uv.x, uv.y), vec2(0.5f, 0.5f))); // nastane krog, ker je razdalja od centra konstantna
}

vec4 colorize (float col, float a) {
	
	vec4 pallete;
	
//	// grayscale
//	pallete = vec4(col, col, col, a);  // col je podan red kanal

//	// monochrome
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.g = float(col >= 0.0f); // en kanal setamo, da je ves čas 0, razen ko je poln (? ... full je white?)
	
//	// darken vse kar ni belo
	pallete = vec4(col, col, col, a);  // col je podan red kanal
	pallete.r = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
	pallete.g = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
	pallete.b = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
	
//	// raznobarvno
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = float(col > 0.3 && col < 0.7 || col > 0.9); 
//	pallete.g = float(col > 0.7); // višja vrednost od dveh ...?
//	pallete.b = float(col > 0.5 || col > 0.9); // višja vrednost od dveh ...?
	
//	// ta bi bila za ščit
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.g = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.b = float(col > 0.3); // višja vrednost od dveh ...?
	
	return pallete; // ta vrednost gre v barvo
}


void fragment(){
	vec4 bg = texture(TEXTURE, UV - TIME/speed); // tukjaj je že notri premikanje
	
	COLOR = bg;
	COLOR.r = gradient(UV); // red kanal damo rezultat gradient funkcije 
	
	// množimo oz. združimo red channel z intensity in teksturo noisa
	COLOR.r = clamp(COLOR.r * bg.r * intensity * 10.0f, 0.0f, 1.0f); // klempam, da ne gre pod nulo in ne nad ena (ker je to barvni kanal)
	//	current color * intensity
	COLOR.r = floor(COLOR.r * layers) / layers; // floor ... zaokrožimo zato, ker ker je št. lejerja zmeraj cela številka ... delimo z lejerji, da je vsak lejer na 0.2 vrednosti
	COLOR.a = float(COLOR.r > 0.0f); // ?
	
	COLOR = colorize(COLOR.r, COLOR.a); // igranje z barvami
	
	
}"

[sub_resource type="ShaderMaterial" id="101"]
shader = SubResource("11")
shader_parameter/intensity = 1.0
shader_parameter/layers = 4.0
shader_parameter/speed = 4.0

[sub_resource type="FastNoiseLite" id="111"]

[sub_resource type="NoiseTexture2D" id="102"]
width = 48
height = 48
seamless = true
noise = SubResource("111")

[sub_resource type="Shader" id="103"]
code = "shader_type canvas_item;
render_mode blend_mix ;

uniform float intensity = 0.5f;
uniform float layers = 5.0f;
uniform float speed = 4.0f;

float gradient(vec2 uv){
	
	// čekiramo razdaljo od centra sprajta do koordinate trenutne pike
	return (0.5f - distance(vec2(uv.x, uv.y), vec2(0.5f, 0.5f))); // nastane krog, ker je razdalja od centra konstantna
}

vec4 colorize (float col, float a) {
	
	vec4 pallete;
	
//	// grayscale
//	pallete = vec4(col, col, col, a);  // col je podan red kanal

//	// monochrome
	pallete = vec4(col, col, col, a);  // col je podan red kanal
	pallete.g = float(col >= 0.0f); // en kanal setamo, da je ves čas 0, razen ko je poln (? ... full je white?)
	
//	// darken vse kar ni belo
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.g = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.b = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
	
//	// raznobarvno
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = float(col > 0.3 && col < 0.7 || col > 0.9); 
//	pallete.g = float(col > 0.7); // višja vrednost od dveh ...?
//	pallete.b = float(col > 0.5 || col > 0.9); // višja vrednost od dveh ...?
	
//	// ta bi bila za ščit
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.g = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.b = float(col > 0.3); // višja vrednost od dveh ...?
	
	return pallete; // ta vrednost gre v barvo
}


void fragment(){
	vec4 bg = texture(TEXTURE, UV - TIME/speed); // tukjaj je že notri premikanje
	
	COLOR = bg;
	COLOR.r = gradient(UV); // red kanal damo rezultat gradient funkcije 
	
	// množimo oz. združimo red channel z intensity in teksturo noisa
	COLOR.r = clamp(COLOR.r * bg.r * intensity * 10.0f, 0.0f, 1.0f); // klempam, da ne gre pod nulo in ne nad ena (ker je to barvni kanal)
	//	current color * intensity
	COLOR.r = floor(COLOR.r * layers) / layers; // floor ... zaokrožimo zato, ker ker je št. lejerja zmeraj cela številka ... delimo z lejerji, da je vsak lejer na 0.2 vrednosti
	COLOR.a = float(COLOR.r > 0.0f); // ?
	
	COLOR = colorize(COLOR.r, COLOR.a); // igranje z barvami
	
	
}"

[sub_resource type="ShaderMaterial" id="104"]
shader = SubResource("103")
shader_parameter/intensity = 1.0
shader_parameter/layers = 4.0
shader_parameter/speed = 4.0

[sub_resource type="Shader" id="12"]
code = "shader_type canvas_item;
render_mode blend_mix ;

uniform float intensity = 0.5f;
uniform float layers = 5.0f;
uniform float speed = 4.0f;

float gradient(vec2 uv){
	
	// čekiramo razdaljo od centra sprajta do koordinate trenutne pike
	return (0.5f - distance(vec2(uv.x, uv.y), vec2(0.5f, 0.5f))); // nastane krog, ker je razdalja od centra konstantna
}

vec4 colorize (float col, float a) {
	
	vec4 pallete;
	
//	// grayscale
	pallete = vec4(col, col, col, a);  // col je podan red kanal

//	// monochrome
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.g = float(col >= 0.0f); // en kanal setamo, da je ves čas 0, razen ko je poln (? ... full je white?)
	
//	// darken vse kar ni belo
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.g = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.b = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
	
//	// raznobarvno
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = float(col > 0.3 && col < 0.7 || col > 0.9); 
//	pallete.g = float(col > 0.7); // višja vrednost od dveh ...?
//	pallete.b = float(col > 0.5 || col > 0.9); // višja vrednost od dveh ...?
	
//	// ta bi bila za ščit
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.g = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.b = float(col > 0.3); // višja vrednost od dveh ...?
	
	return pallete; // ta vrednost gre v barvo
}


void fragment(){
	vec4 bg = texture(TEXTURE, UV - TIME/speed); // tukjaj je že notri premikanje
	
	COLOR = bg;
	COLOR.r = gradient(UV); // red kanal damo rezultat gradient funkcije 
	
	// množimo oz. združimo red channel z intensity in teksturo noisa
	COLOR.r = clamp(COLOR.r * bg.r * intensity * 10.0f, 0.0f, 1.0f); // klempam, da ne gre pod nulo in ne nad ena (ker je to barvni kanal)
	//	current color * intensity
	COLOR.r = floor(COLOR.r * layers) / layers; // floor ... zaokrožimo zato, ker ker je št. lejerja zmeraj cela številka ... delimo z lejerji, da je vsak lejer na 0.2 vrednosti
	COLOR.a = float(COLOR.r > 0.0f); // ?
	
	COLOR = colorize(COLOR.r, COLOR.a); // igranje z barvami
	
	
}"

[sub_resource type="ShaderMaterial" id="105"]
shader = SubResource("12")
shader_parameter/intensity = 1.0
shader_parameter/layers = 4.0
shader_parameter/speed = 4.0

[sub_resource type="Shader" id="26"]
code = "shader_type canvas_item;
render_mode blend_mix ;

uniform float intensity = 0.5f;
uniform float layers = 5.0f;
uniform float speed = 4.0f;

float gradient(vec2 uv){
	
	// čekiramo razdaljo od centra sprajta do koordinate trenutne pike
	return (0.5f - distance(vec2(uv.x, uv.y), vec2(0.5f, 0.5f))); // nastane krog, ker je razdalja od centra konstantna
}

vec4 colorize (float col, float a) {
	
	vec4 pallete;
	
//	// grayscale
//	pallete = vec4(col, col, col, a);  // col je podan red kanal

//	// monochrome
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.g = float(col >= 0.0f); // en kanal setamo, da je ves čas 0, razen ko je poln (? ... full je white?)
	
//	// darken vse kar ni belo
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.g = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.b = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
	
//	// raznobarvno
	pallete = vec4(col, col, col, a);  // col je podan red kanal
	pallete.r = float(col > 0.3 && col < 0.7 || col > 0.9); 
	pallete.g = float(col > 0.7); // višja vrednost od dveh ...?
	pallete.b = float(col > 0.5 || col > 0.9); // višja vrednost od dveh ...?
	
//	// ta bi bila za ščit
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.g = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.b = float(col > 0.3); // višja vrednost od dveh ...?
	
	return pallete; // ta vrednost gre v barvo
}


void fragment(){
	vec4 bg = texture(TEXTURE, UV - TIME/speed); // tukjaj je že notri premikanje
	
	COLOR = bg;
	COLOR.r = gradient(UV); // red kanal damo rezultat gradient funkcije 
	
	// množimo oz. združimo red channel z intensity in teksturo noisa
	COLOR.r = clamp(COLOR.r * bg.r * intensity * 10.0f, 0.0f, 1.0f); // klempam, da ne gre pod nulo in ne nad ena (ker je to barvni kanal)
	//	current color * intensity
	COLOR.r = floor(COLOR.r * layers) / layers; // floor ... zaokrožimo zato, ker ker je št. lejerja zmeraj cela številka ... delimo z lejerji, da je vsak lejer na 0.2 vrednosti
	COLOR.a = float(COLOR.r > 0.0f); // ?
	
	COLOR = colorize(COLOR.r, COLOR.a); // igranje z barvami
	
	
}"

[sub_resource type="ShaderMaterial" id="106"]
shader = SubResource("26")
shader_parameter/intensity = 1.0
shader_parameter/layers = 4.0
shader_parameter/speed = 4.0

[sub_resource type="Shader" id="17"]
code = "shader_type canvas_item;
render_mode blend_mix ;

uniform float intensity = 0.5f;
uniform float layers = 5.0f;
uniform float speed = 4.0f;

float gradient(vec2 uv){
	
	// čekiramo razdaljo od centra sprajta do koordinate trenutne pike
	return (0.5f - distance(vec2(uv.x, uv.y), vec2(0.5f, 0.5f))); // nastane krog, ker je razdalja od centra konstantna
}

vec4 colorize (float col, float a) {
	
	vec4 pallete;
	
//	// grayscale
//	pallete = vec4(col, col, col, a);  // col je podan red kanal

//	// monochrome
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.g = float(col >= 0.0f); // en kanal setamo, da je ves čas 0, razen ko je poln (? ... full je white?)
	
//	// darken vse kar ni belo
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.g = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.b = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
	
//	// raznobarvno
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = float(col > 0.3 && col < 0.7 || col > 0.9); 
//	pallete.g = float(col > 0.7); // višja vrednost od dveh ...?
//	pallete.b = float(col > 0.5 || col > 0.9); // višja vrednost od dveh ...?
	
//	// ta bi bila za ščit
	pallete = vec4(col, col, col, a);  // col je podan red kanal
	pallete.r = float(col > 0.3); // višja vrednost od dveh ...?
	pallete.g = float(col > 0.3); // višja vrednost od dveh ...?
	pallete.b = float(col > 0.3); // višja vrednost od dveh ...?
	
	return pallete; // ta vrednost gre v barvo
}


void fragment(){
	vec4 bg = texture(TEXTURE, UV - TIME/speed); // tukjaj je že notri premikanje
	
	COLOR = bg;
	COLOR.r = gradient(UV); // red kanal damo rezultat gradient funkcije 
	
	// množimo oz. združimo red channel z intensity in teksturo noisa
	COLOR.r = clamp(COLOR.r * bg.r * intensity * 10.0f, 0.0f, 1.0f); // klempam, da ne gre pod nulo in ne nad ena (ker je to barvni kanal)
	//	current color * intensity
	COLOR.r = floor(COLOR.r * layers) / layers; // floor ... zaokrožimo zato, ker ker je št. lejerja zmeraj cela številka ... delimo z lejerji, da je vsak lejer na 0.2 vrednosti
	COLOR.a = float(COLOR.r > 0.0f); // ?
	
	COLOR = colorize(COLOR.r, COLOR.a); // igranje z barvami
	
	
}"

[sub_resource type="ShaderMaterial" id="18"]
shader = SubResource("17")
shader_parameter/intensity = 1.0
shader_parameter/layers = 4.0
shader_parameter/speed = 4.0

[sub_resource type="Shader" id="21"]
code = "shader_type canvas_item;
render_mode blend_mix ;

uniform float intensity = 0.5f;
uniform float layers = 5.0f;
uniform float speed = 4.0f;

float gradient(vec2 uv){
	
	// čekiramo razdaljo od centra sprajta do koordinate trenutne pike
//	return (0.5f - distance(vec2(uv.x, uv.y), vec2(0.5f, 0.5f))); // nastane krog, ker je razdalja od centra konstantna
	return (0.5f - distance(vec2(0.0f, uv.y), vec2(0.0f, 0.5f))); // gradient from top to bottom, focus middle
//	return (1.0f - distance(vec2(0.0f, uv.y), vec2(0.0f, 0.0f))); // gradient from top
//	return (1.0f - distance(vec2(0.0f, uv.y), vec2(0.0f, 0.0f))); // gradient from bottom
}

vec4 colorize (float col, float a) {
	
	vec4 pallete;
	
//	// grayscale
//	pallete = vec4(col, col, col, a);  // col je podan red kanal

//	// monochrome
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.g = float(col >= 0.0f); // en kanal setamo, da je ves čas 0, razen ko je poln (? ... full je white?)
	
//	// darken vse kar ni belo
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.g = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.b = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
	
//	// raznobarvno
	pallete = vec4(col, col, col, a);  // col je podan red kanal
	pallete.r = float(col > 0.3 && col < 0.7 || col > 0.9); 
	pallete.g = float(col > 0.7); // višja vrednost od dveh ...?
	pallete.b = float(col > 0.5 || col > 0.9); // višja vrednost od dveh ...?
	
//	// ta bi bila za ščit
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.g = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.b = float(col > 0.3); // višja vrednost od dveh ...?
	
	return pallete; // ta vrednost gre v barvo
}


void fragment(){
	vec4 bg = texture(TEXTURE, UV - TIME/speed); // tukjaj je že notri premikanje
	
	COLOR = bg;
	COLOR.r = gradient(UV); // red kanal damo rezultat gradient funkcije 
	
	// množimo oz. združimo red channel z intensity in teksturo noisa
	COLOR.r = clamp(COLOR.r * bg.r * intensity * 10.0f, 0.0f, 1.0f); // klempam, da ne gre pod nulo in ne nad ena (ker je to barvni kanal)
	//	current color * intensity
	COLOR.r = floor(COLOR.r * layers) / layers; // floor ... zaokrožimo zato, ker ker je št. lejerja zmeraj cela številka ... delimo z lejerji, da je vsak lejer na 0.2 vrednosti
	COLOR.a = float(COLOR.r > 0.0f); // ?
	
	COLOR = colorize(COLOR.r, COLOR.a); // igranje z barvami
	
	
}"

[sub_resource type="ShaderMaterial" id="22"]
shader = SubResource("21")
shader_parameter/intensity = 1.0
shader_parameter/layers = 4.0
shader_parameter/speed = 4.0

[sub_resource type="Shader" id="23"]
code = "shader_type canvas_item;
render_mode blend_mix ;

uniform float intensity = 0.5f;
uniform float layers = 5.0f;
uniform float speed = 4.0f;

float gradient(vec2 uv){
	
	// čekiramo razdaljo od centra sprajta do koordinate trenutne pike
//	return (0.5f - distance(vec2(uv.x, uv.y), vec2(0.5f, 0.5f))); // nastane krog, ker je razdalja od centra konstantna
//	return (0.5f - distance(vec2(0.0f, uv.y), vec2(0.0f, 0.5f))); // gradient from top to bottom, focus middle
	return (1.0f - distance(vec2(0.0f, uv.y), vec2(0.0f, 1.0f))); // gradient from top
//	return (1.0f - distance(vec2(0.0f, uv.y), vec2(0.0f, 0.0f))); // gradient from bottom
}

vec4 colorize (float col, float a) {
	
	vec4 pallete;
	
//	// grayscale
//	pallete = vec4(col, col, col, a);  // col je podan red kanal

//	// monochrome
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.g = float(col >= 0.0f); // en kanal setamo, da je ves čas 0, razen ko je poln (? ... full je white?)
	
//	// darken vse kar ni belo
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.g = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.b = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
	
//	// raznobarvno
	pallete = vec4(col, col, col, a);  // col je podan red kanal
	pallete.r = float(col > 0.3 && col < 0.7 || col > 0.9); 
	pallete.g = float(col > 0.7); // višja vrednost od dveh ...?
	pallete.b = float(col > 0.5 || col > 0.9); // višja vrednost od dveh ...?
	
//	// ta bi bila za ščit
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.g = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.b = float(col > 0.3); // višja vrednost od dveh ...?
	
	return pallete; // ta vrednost gre v barvo
}


void fragment(){
	vec4 bg = texture(TEXTURE, UV - TIME/speed); // tukjaj je že notri premikanje
	
	COLOR = bg;
	COLOR.r = gradient(UV); // red kanal damo rezultat gradient funkcije 
	
	// množimo oz. združimo red channel z intensity in teksturo noisa
	COLOR.r = clamp(COLOR.r * bg.r * intensity * 10.0f, 0.0f, 1.0f); // klempam, da ne gre pod nulo in ne nad ena (ker je to barvni kanal)
	//	current color * intensity
	COLOR.r = floor(COLOR.r * layers) / layers; // floor ... zaokrožimo zato, ker ker je št. lejerja zmeraj cela številka ... delimo z lejerji, da je vsak lejer na 0.2 vrednosti
	COLOR.a = float(COLOR.r > 0.0f); // ?
	
	COLOR = colorize(COLOR.r, COLOR.a); // igranje z barvami
	
	
}"

[sub_resource type="ShaderMaterial" id="24"]
shader = SubResource("23")
shader_parameter/intensity = 1.0
shader_parameter/layers = 4.0
shader_parameter/speed = 4.0

[sub_resource type="Shader" id="19"]
code = "shader_type canvas_item;
render_mode blend_mix ;

uniform float intensity = 0.5f;
uniform float layers = 5.0f;
uniform float speed = 4.0f;

float gradient(vec2 uv){
	
	// čekiramo razdaljo od centra sprajta do koordinate trenutne pike
//	return (0.5f - distance(vec2(uv.x, uv.y), vec2(0.5f, 0.5f))); // nastane krog, ker je razdalja od centra konstantna
//	return (0.5f - distance(vec2(0.0f, uv.y), vec2(0.0f, 0.5f))); // gradient from top to bottom, focus middle
//	return (1.0f - distance(vec2(0.0f, uv.y), vec2(0.0f, 0.0f))); // gradient from top
	return (1.0f - distance(vec2(0.0f, uv.y), vec2(0.0f, 0.0f))); // gradient from bottom
}

vec4 colorize (float col, float a) {
	
	vec4 pallete;
	
//	// grayscale
//	pallete = vec4(col, col, col, a);  // col je podan red kanal

//	// monochrome
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.g = float(col >= 0.0f); // en kanal setamo, da je ves čas 0, razen ko je poln (? ... full je white?)
	
//	// darken vse kar ni belo
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.g = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
//	pallete.b = max(float(col >= 1.0f), col / 3.0f); // višja vrednost od dveh ...?
	
//	// raznobarvno
	pallete = vec4(col, col, col, a);  // col je podan red kanal
	pallete.r = float(col > 0.3 && col < 0.7 || col > 0.9); 
	pallete.g = float(col > 0.7); // višja vrednost od dveh ...?
	pallete.b = float(col > 0.5 || col > 0.9); // višja vrednost od dveh ...?
	
//	// ta bi bila za ščit
//	pallete = vec4(col, col, col, a);  // col je podan red kanal
//	pallete.r = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.g = float(col > 0.3); // višja vrednost od dveh ...?
//	pallete.b = float(col > 0.3); // višja vrednost od dveh ...?
	
	return pallete; // ta vrednost gre v barvo
}


void fragment(){
	vec4 bg = texture(TEXTURE, UV - TIME/speed); // tukjaj je že notri premikanje
	
	COLOR = bg;
	COLOR.r = gradient(UV); // red kanal damo rezultat gradient funkcije 
	
	// množimo oz. združimo red channel z intensity in teksturo noisa
	COLOR.r = clamp(COLOR.r * bg.r * intensity * 10.0f, 0.0f, 1.0f); // klempam, da ne gre pod nulo in ne nad ena (ker je to barvni kanal)
	//	current color * intensity
	COLOR.r = floor(COLOR.r * layers) / layers; // floor ... zaokrožimo zato, ker ker je št. lejerja zmeraj cela številka ... delimo z lejerji, da je vsak lejer na 0.2 vrednosti
	COLOR.a = float(COLOR.r > 0.0f); // ?
	
	COLOR = colorize(COLOR.r, COLOR.a); // igranje z barvami
	
	
}"

[sub_resource type="ShaderMaterial" id="20"]
shader = SubResource("19")
shader_parameter/intensity = 1.0
shader_parameter/layers = 4.0
shader_parameter/speed = 4.0

[sub_resource type="Shader" id="107"]
code = "shader_type canvas_item;
render_mode blend_mix;

uniform float max_line_width = 10.0;
uniform float min_line_width = 5.0;
uniform float freq = 1.0;
uniform float block_size = 20.0;
uniform vec4 starting_colour = vec4(0,0,0,1);
uniform vec4 ending_colour = vec4(1);

const float pi = 3.1415;
const int ang_res = 16;
const int grad_res = 8;

float hash(vec2 p, float s) {
	return fract(35.1 * sin(dot(vec3(112.3, 459.2, 753.2), vec3(p, s))));
}

float noise(vec2 p, float s) {
	vec2 d = vec2(0, 1);
	vec2 b = floor(p);
	vec2 f = fract(p);
	return mix(
		mix(hash(b + d.xx, s), hash(b + d.yx, s), f.x),
		mix(hash(b + d.xy, s), hash(b + d.yy, s), f.x), f.y);
}

float getLineWidth(vec2 p, float s) {
	p /= block_size;
	float w = 0.0;
	float intensity = 1.0;
	for (int i = 0; i < 3; i++) {
		w = mix(w, noise(p, s), intensity);
		p /= 2.0;
		intensity /= 2.0;
	}
	
	return mix(max_line_width, min_line_width, w);
}

bool pixelInRange(sampler2D text, vec2 uv, vec2 dist) {
	float alpha = 0.0;
	for (int i = 0; i < ang_res; i++) {
		float angle = 2.0 * pi * float(i) / float(ang_res);
		vec2 disp = dist * vec2(cos(angle), sin(angle));
		if (texture(text, uv + disp).a > 0.0) return true;
	}
	return false;
}

float getClosestDistance(sampler2D text, vec2 uv, vec2 maxDist) {
	if (!pixelInRange(text, uv, maxDist)) return -1.0;
	
	float hi = 1.0; float lo = 0.0;
	
	for (int i = 1; i <= grad_res; i++) {
		float curr = (hi + lo) / 2.0;
		if (pixelInRange(text, uv, curr * maxDist)) {
			hi = curr;
		}
		else {
			lo = curr;
		}
	}
	return hi;
	
}

void fragment() {
	float timeStep = floor(freq * TIME);
	vec2 scaledDist = TEXTURE_PIXEL_SIZE;
	scaledDist *= getLineWidth(UV / TEXTURE_PIXEL_SIZE, timeStep);
	float w = getClosestDistance(TEXTURE, UV, scaledDist);
	
	if (( w > 0.0) && (texture(TEXTURE, UV).a < 0.2)) {
		COLOR = mix(starting_colour, ending_colour, tanh(3.0*w));
	}
	else {
		COLOR = texture(TEXTURE, UV);
	}
	
}"

[sub_resource type="ShaderMaterial" id="97"]
shader = SubResource("107")
shader_parameter/max_line_width = 10.0
shader_parameter/min_line_width = 4.0
shader_parameter/freq = 7.0
shader_parameter/block_size = 5.0
shader_parameter/starting_colour = Plane(1, 0, 1, 1)
shader_parameter/ending_colour = Plane(1, 0, 1, 0)

[node name="Arena" type="Node2D"]
script = ExtResource("1")

[node name="BackgroundLayer Z0" type="CanvasLayer" parent="."]
layer = -1
script = ExtResource("17")

[node name="Background" type="Node2D" parent="BackgroundLayer Z0"]

[node name="ColorRect" type="ColorRect" parent="BackgroundLayer Z0/Background"]
color = Color(0.054902, 0.709804, 0.498039, 1)

[node name="Woda" type="ColorRect" parent="BackgroundLayer Z0/Background"]
modulate = Color(1, 1, 1, 0.0509804)
material = SubResource("114")

[node name="Light2D" type="PointLight2D" parent="BackgroundLayer Z0/Background"]
visible = false
z_index = 1
position = Vector2(320.5, 181)
scale = Vector2(1.95988, 1.10416)
color = Color(1, 1, 0.388235, 1)
energy = 0.69
texture = ExtResource("5")
texture_scale = 2.92

[node name="EffectsLayer Z1" type="CanvasLayer" parent="."]
script = ExtResource("18")

[node name="Shadows" type="Sprite2D" parent="EffectsLayer Z1"]
modulate = Color(1, 1, 1, 0.752941)
material = SubResource("88")
texture = SubResource("92")
centered = false
flip_v = true

[node name="Colors" type="Sprite2D" parent="EffectsLayer Z1"]
modulate = Color(1, 1, 1, 0.752941)
material = SubResource("86")
texture = SubResource("93")
centered = false
flip_v = true

[node name="Viewport" type="SubViewport" parent="EffectsLayer Z1"]
transparent_bg = true
size = Vector2i(640, 360)

[node name="Effects" type="Node2D" parent="EffectsLayer Z1/Viewport"]
script = ExtResource("9")

[node name="BodiesLayer Z2" type="CanvasLayer" parent="."]
layer = 2
script = ExtResource("8")

[node name="Player" parent="BodiesLayer Z2" instance=ExtResource("2")]
position = Vector2(73, 126)
bounce_size = 0.547

[node name="AnimationPlayer" parent="BodiesLayer Z2/Player" index="5"]
libraries = {
"": SubResource("AnimationLibrary_g6pnq")
}

[node name="Disabled Plejer" parent="BodiesLayer Z2" instance=ExtResource("2")]
position = Vector2(441, 126)
player_name = "P2"
inputs_enabled = false

[node name="AnimationPlayer" parent="BodiesLayer Z2/Disabled Plejer" index="5"]
libraries = {
"": SubResource("AnimationLibrary_3ajql")
}

[node name="FejkPlejer" type="CharacterBody2D" parent="BodiesLayer Z2"]
position = Vector2(521, 190)
script = ExtResource("13")

[node name="CollisionPolygon2D" type="CollisionPolygon2D" parent="BodiesLayer Z2/FejkPlejer"]
position = Vector2(0, 0.5)
rotation = 1.57079
polygon = PackedVector2Array(-1.99997, -4.00001, -5, -3.13719e-05, -5.00001, 1.99997, -4.00002, 2.99997, 2.99998, 3.00002, 3.99999, 2.00003, 4, 2.50975e-05, 1.00003, -3.99999)

[node name="Bolt" type="Sprite2D" parent="BodiesLayer Z2/FejkPlejer"]
position = Vector2(0, 0.5)
rotation = 1.5708
texture = ExtResource("7")

[node name="Shadows" type="ColorRect" parent="BodiesLayer Z2"]
visible = false
material = SubResource("63")

[node name="Colors" type="ColorRect" parent="BodiesLayer Z2"]
visible = false
material = SubResource("16")

[node name="LevelLayer Z3" type="CanvasLayer" parent="."]
layer = 3
script = ExtResource("15")

[node name="Level_00" type="Node2D" parent="LevelLayer Z3"]
z_index = -1

[node name="ArenaTilemap" type="TileMap" parent="LevelLayer Z3/Level_00"]
material = SubResource("416")
tile_set = SubResource("108")
format = 2

[node name="Shadows" type="ColorRect" parent="LevelLayer Z3"]
material = SubResource("83")

[node name="Colors" type="ColorRect" parent="LevelLayer Z3"]
material = SubResource("65")

[node name="NeonGow" type="ColorRect" parent="LevelLayer Z3"]
visible = false
material = SubResource("414")

[node name="NeonDust" type="ColorRect" parent="LevelLayer Z3"]
material = SubResource("99")

[node name="JuicyCamera" parent="." instance=ExtResource("11")]
visible = false
z_index = 6

[node name="šejderji" type="Node2D" parent="."]
visible = false
position = Vector2(407.401, 53.2947)

[node name="v1" type="Sprite2D" parent="šejderji"]
material = SubResource("2")
position = Vector2(68, 106)
texture = SubResource("3")

[node name="v3" type="Sprite2D" parent="šejderji"]
material = SubResource("101")
position = Vector2(189, 104)
texture = SubResource("102")

[node name="v4" type="Sprite2D" parent="šejderji"]
material = SubResource("104")
position = Vector2(70, 172)
texture = SubResource("102")

[node name="v2" type="Sprite2D" parent="šejderji"]
material = SubResource("105")
position = Vector2(127, 106)
texture = SubResource("102")

[node name="v5" type="Sprite2D" parent="šejderji"]
material = SubResource("106")
position = Vector2(130, 172)
texture = SubResource("102")

[node name="v6" type="Sprite2D" parent="šejderji"]
material = SubResource("18")
position = Vector2(191, 172)
texture = SubResource("102")

[node name="v7 hor" type="Sprite2D" parent="šejderji"]
material = SubResource("22")
position = Vector2(71, 234)
texture = SubResource("102")

[node name="v7 hor2" type="Sprite2D" parent="šejderji"]
material = SubResource("24")
position = Vector2(132, 234)
texture = SubResource("102")

[node name="v7 hor3" type="Sprite2D" parent="šejderji"]
material = SubResource("20")
position = Vector2(194, 234)
texture = SubResource("102")

[node name="neon light" type="Sprite2D" parent="šejderji"]
material = SubResource("97")
position = Vector2(-36.401, 197.705)
texture = ExtResource("12")

[editable path="BodiesLayer Z2/Player"]
[editable path="BodiesLayer Z2/Disabled Plejer"]
