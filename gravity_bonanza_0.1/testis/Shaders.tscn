[gd_scene load_steps=25 format=2]

[ext_resource path="res://testis/tile_lcd.png" type="Texture" id=1]
[ext_resource path="res://testis/tile_raketa.png" type="Texture" id=2]
[ext_resource path="res://testis/tile_lcd_alt.png" type="Texture" id=3]
[ext_resource path="res://testis/tu_pixels.png" type="Texture" id=4]

[sub_resource type="Shader" id=1]
code = "shader_type canvas_item;

uniform vec4 flashColor : hint_color;
uniform float blue = 0.5;
uniform float colorRange : hint_range(0,1) = 0.5; //difolt vrednost je .5

// unifrom array of colors

void fragment(){
	COLOR = texture(TEXTURE, UV + vec2(0.2, 0.3)); //read from texture
	if (COLOR.r + COLOR.g + COLOR.b > 0.0)
//		COLOR.g = blue;
//		COLOR.b = 1.0;
		COLOR = vec4(0.4, 0.6, 0.9, 1.0);
//		COLOR = vec4(UV, 0.5, 1.0);
//		COLOR.rgb = mix (0.5, 0.5, 0.5).rgb;
}

void vertex() {
	VERTEX += vec2(10.0, 0.0);
  // Animate Sprite moving in big circle around its location
	VERTEX += vec2(cos(TIME)*1.0, sin(TIME)*1.0);
}"

[sub_resource type="ShaderMaterial" id=2]
shader = SubResource( 1 )
shader_param/flashColor = null
shader_param/blue = 0.5
shader_param/colorRange = 0.5

[sub_resource type="Shader" id=3]
code = "shader_type canvas_item;
uniform sampler2D Colormap : hint_albedo;

void fragment() {
// Get the fragment location
	vec3 location = vec3(UV, 0.0);

// Get the colors from the image at specified location
	vec3 colorIn;
	float alphaIn;
	{
		vec4 TEXTURE_tex_read = texture(TEXTURE, location.xy);
		colorIn = TEXTURE_tex_read.rgb;
		alphaIn = TEXTURE_tex_read.a;
	}

// get the greyscale value through the highest of r, g, and b
	float grey;
	{
		vec3 c = colorIn;
		float max1 = max(c.r, c.g);
		float max2 = max(max1, c.b);
		grey = max2;
	}

// Read the colormap and use the greyscale value to map in the new color.
	vec3 colorOut;
	float alphaOut;
	{
		vec4 n_tex_read = texture(Colormap, vec2(grey, 0.0));
		colorOut = n_tex_read.rgb;
		alphaOut = n_tex_read.a;
	}

// Profit.
	COLOR.rgb = colorOut;
	COLOR.a = alphaIn;

}"

[sub_resource type="Gradient" id=4]
offsets = PoolRealArray( 0, 0.283582, 0.648188, 1 )
colors = PoolColorArray( 0.203629, 0.921875, 0.122437, 1, 0.451757, 0.518088, 0.951193, 1, 0.960188, 0.552798, 0.552798, 1, 1, 1, 1, 1 )

[sub_resource type="GradientTexture" id=5]
gradient = SubResource( 4 )

[sub_resource type="ShaderMaterial" id=6]
shader = SubResource( 3 )
shader_param/Colormap = SubResource( 5 )

[sub_resource type="Shader" id=7]
code = "shader_type canvas_item;
//render_mode blend_mix;

void fragment(){
	vec4 color = texture(TEXTURE, UV);
    // if the pixel has enough red
	if (color.r  > 50.0){
        // set its color to green
        color.g = 205.0;  // or color = vec4(0,255.0,0,color.a)
	}
    // otherwise
	else {
        // set its color to blue
	color.b = 205.0;  // or color = vec4(0,0,255.0,color.a)
	}
	COLOR = color;
}"

[sub_resource type="ShaderMaterial" id=8]
shader = SubResource( 7 )

[sub_resource type="Shader" id=11]
code = "shader_type canvas_item;

uniform float pixelFactor : hint_range(0, 1) = 0.5;

uniform sampler2D Colormap : hint_albedo;
uniform sampler2D noise;
uniform vec2 scrolling = vec2(0.0,0.0);
//uniform vec2 scrolling = vec2(-0.1,0.08);

void fragment() {
	
	float noise_static = texture(noise, UV).b;
	float noise_val = texture(noise, UV + TIME * scrolling).r;
//	float noise_

	vec2 pixelNumber = vec2(textureSize(TEXTURE, 0)) / pixelFactor; // število pixlov
	vec2 pixelatedUV = ((floor(UV * pixelNumber) + 0.5) / pixelNumber) + TIME/5.0; // These pixelizations are aligned to the top left. If you do a bit of trickery with offsets, you can centre them. 
	COLOR = texture(noise,pixelatedUV);

//	COLOR.rgb = vec3(noise_static, 0.5, noise_val);
}

"

[sub_resource type="Gradient" id=12]
interpolation_mode = 1
colors = PoolColorArray( 1, 1, 1, 1, 1, 1, 1, 1 )

[sub_resource type="GradientTexture" id=13]
gradient = SubResource( 12 )

[sub_resource type="OpenSimplexNoise" id=15]
seed = 5
octaves = 1
period = 40.2

[sub_resource type="NoiseTexture" id=16]
seamless = true
noise = SubResource( 15 )

[sub_resource type="ShaderMaterial" id=14]
shader = SubResource( 11 )
shader_param/pixelFactor = 0.5
shader_param/scrolling = Vector2( 1, 0 )
shader_param/Colormap = SubResource( 13 )
shader_param/noise = SubResource( 16 )

[sub_resource type="Shader" id=23]
code = "shader_type canvas_item;

uniform float pixelFactor : hint_range(0, 1) = 0.5;

void fragment() {
	// pixel number naj bo proporcionalna to sprite resolution ... multiply pixel texture width sprite size
//	vec2 pixelNumber = vec2(textureSize(TEXTURE, 0)) / 10.0; // število pixlov
	vec2 pixelNumber = vec2(32, 32);
//	vec2 pixelatedUV = round(UV * pixelFactor) / pixelFactor; // snaping (round) to pixelsize and dividing to ge back to 0 - 1 interval
	vec2 pixelatedUV = round(UV * pixelNumber) / pixelNumber; // snaping (round) to pixelsize and dividing to ge back to 0 - 1 interval
//	COLOR = vec4(pixelatedUV.x, pixelatedUV.y, 0, 1);
	COLOR = texture(TEXTURE, pixelatedUV);
}"

[sub_resource type="ShaderMaterial" id=22]
shader = SubResource( 23 )
shader_param/pixelFactor = 0.43

[sub_resource type="OpenSimplexNoise" id=20]
seed = 3
octaves = 1
period = 0.1
persistence = 0.585
lacunarity = 0.14

[sub_resource type="NoiseTexture" id=19]
width = 32
height = 32
seamless = true
noise = SubResource( 20 )

[sub_resource type="Shader" id=21]
code = "shader_type canvas_item;

uniform float pixelFactor : hint_range(0, 1) = 0.5;

void fragment() {
	// pixel number naj bo proporcionalna to sprite resolution ... multiply pixel texture width sprite size
	vec2 pixelNumber = vec2(textureSize(TEXTURE, 0)) / pixelFactor; // število pixlov
//	vec2 pixelatedUV = round(UV * pixelFactor) / pixelFactor; // snaping (round) to pixelsize and dividing to ge back to 0 - 1 interval
//	vec2 pixelatedUV = round(UV * pixelNumber) / pixelNumber; // snaping (round) to pixelsize and dividing to ge back to 0 - 1 interval
	vec2 pixelatedUV = (floor(UV * pixelNumber) + 0.5) / pixelNumber; // These pixelizations are aligned to the top left. If you do a bit of trickery with offsets, you can centre them. 
//	COLOR = vec4(pixelatedUV.x, pixelatedUV.y, 0, 1);
	COLOR = texture(TEXTURE, pixelatedUV);
}"

[sub_resource type="ShaderMaterial" id=17]
shader = SubResource( 21 )
shader_param/pixelFactor = 12.481

[node name="Shaders" type="Node2D"]

[node name="TileLcd" type="Sprite" parent="."]
visible = false
material = SubResource( 2 )
position = Vector2( 208, 144 )
texture = ExtResource( 1 )

[node name="ColorByBrightness" type="Sprite" parent="."]
visible = false
material = SubResource( 6 )
position = Vector2( 208, 144 )
texture = ExtResource( 2 )

[node name="lcd" type="Sprite" parent="."]
visible = false
material = SubResource( 8 )
texture = ExtResource( 3 )

[node name="scroll noise" type="Sprite" parent="."]
material = SubResource( 14 )
position = Vector2( 304, 192 )
texture = ExtResource( 3 )

[node name="noise" type="Sprite" parent="."]
visible = false
material = SubResource( 22 )
position = Vector2( 336, 192 )
texture = SubResource( 19 )

[node name="pixel_texture" type="Sprite" parent="."]
visible = false
material = SubResource( 17 )
position = Vector2( 600, 328 )
scale = Vector2( 0.371457, 0.371457 )
texture = ExtResource( 4 )
