[gd_scene load_steps=16 format=2]

[ext_resource path="res://ViewContainer.gd" type="Script" id=1]
[ext_resource path="res://arena/Arena.tscn" type="PackedScene" id=2]
[ext_resource path="res://resources/shader_2dcolor_manipulator.gdshader" type="Shader" id=3]
[ext_resource path="res://resources/graphics/light.png" type="Texture" id=5]

[sub_resource type="Shader" id=40]
code = "shader_type canvas_item;
//render_mode skip_vertex_transform;

//blend_mix - Mix blend mode (alpha is transparency), default.
//blend_add - Additive blend mode.
//blend_sub - Subtractive blend mode.
//blend_mul - Multiplicative blend mode.
//blend_premul_alpha - Pre-multiplied alpha blend mode.
//blend_disabled - Disable blending, values (including alpha) are written as-is.
//unshaded - Result is just albedo. No lighting/shading happens in material.
//light_only - Only draw on light pass
//skip_vertex_transform - VERTEX/NORMAL/etc need to be transformed manually in vertex function.



// šejder v1 - prepoznava 100% transparenco in aplicira novo barvo na te pixle
// šejder v2 - prepoznava tudi cutout barvo, ki jo potem manipulira
// šejder v3 - prepoznava barvo, ki ji mora dodat senco
// šejder v4 - prepoznava različne barve, ki jim dodaj različne sence
// šejder v5 - dodaja sence za prizemljene objekte

//... simple nadgradnja je če dodam več barv za manipulirat ... al pa celo gradient

// barve
uniform vec4 manipulate_color : hint_color = vec4(1.0, 0.0, 0.0, 1.0); // select color to regirster and manipulate
uniform bool manipulate_other_colors = true;
uniform vec4 transparent_to_color : hint_color = vec4(0.0, 0.0, 0.0, 0.0); // apply color to texture with alpha 0.0

// shadow
uniform vec4 shadow_color : hint_color = vec4(0.0, 0.0, 0.0, 1.0);
uniform float shadow_offset_x = 1.0; // smer offseta ... to niso texli ampak pixli
uniform float shadow_offset_y = 1.0; // smer offseta ... to niso texli ampak pixli
uniform float texture_altitude = 5.0; // količina offseta ... višin texture

// dimenzija teksture za uskladitev texlov s pixli (1/texture original size)  
uniform float texture_width = 640.0;
uniform float texture_height = 360.0;



void fragment(){

	// preračun pravge offseta sence ... pixle konvertamo v texle
	vec2 shadow_offset = vec2(shadow_offset_x / texture_width, shadow_offset_y / texture_height);
	vec2 uvs = UV + shadow_offset * texture_altitude;
	
	// poberemo prikaz texture in apliciramo samo offset še predno apliciramo barvo 
	vec4 color = texture(TEXTURE, uvs);

	
	// manipuliramo izbrano barvo
	if (manipulate_other_colors == false){
		
		// če je barva texture enaka izbrani apliciramo efekt
		if (color == manipulate_color){
			color = shadow_color * color.a;
		}
		// druge barve so brez efekta
		else {
			color.a = 0.0; // 100% transparenca
			color = texture(TEXTURE, UV); // original barva in pozicija
		}
	}
	
	// manipuliramo vse razen izbrane barve
	else if (manipulate_other_colors == true){
		
		// če barva texture ni transparenta apliciramo efekt
		if (color.a > 0.0){
			
			// barva enaka izbrani barvi je brez efekta
			if (color == manipulate_color){
				color.a = 0.0;
				color = texture(TEXTURE, UV);
			}
			// aplciramo efekt na vse druge barve
			else {
				color = shadow_color * color.a;
			}
		}
		// barva transparentnega dela tekture
		else {
			color = transparent_to_color;
		}
		
	}
	
	COLOR = color;
}"

[sub_resource type="ShaderMaterial" id=36]
shader = SubResource( 40 )
shader_param/manipulate_color = Color( 0, 0, 0, 1 )
shader_param/manipulate_other_colors = false
shader_param/transparent_to_color = Color( 0, 0, 0, 0 )
shader_param/shadow_color = Color( 0, 0, 0, 0.27451 )
shader_param/shadow_offset_x = 0.0
shader_param/shadow_offset_y = 1.0
shader_param/texture_altitude = 23.0
shader_param/texture_width = 640.0
shader_param/texture_height = 360.0

[sub_resource type="ViewportTexture" id=37]
viewport_path = NodePath("Viewport Z-0")

[sub_resource type="Shader" id=25]
code = "shader_type canvas_item;

// šejder v1 - prepoznava 100% transparenco in aplicira novo barvo na te pixle
// šejder v2 - prepoznava tudi cutout barvo, ki jo potem manipulira
// šejder v3 - prepoznava barvo, ki ji mora dodat senco
// šejder v4 - prepoznava različne barve, ki jim dodaj različne sence
// šejder v5 - dodaja sence za prizemljene objekte

//... simple nadgradnja je če dodam več barv za manipulirat ... al pa celo gradient

// barve
uniform vec4 manipulate_color : hint_color = vec4(1.0, 0.0, 0.0, 1.0); // select color to regirster and manipulate
uniform bool manipulate_other_colors = true;
uniform vec4 transparent_to_color : hint_color = vec4(0.0, 0.0, 0.0, 0.0); // apply color to texture with alpha 0.0

// shadow
uniform vec4 shadow_color : hint_color = vec4(0.0, 0.0, 0.0, 1.0);
uniform float shadow_offset_x = 1.0; // smer offseta ... to niso texli ampak pixli
uniform float shadow_offset_y = 1.0; // smer offseta ... to niso texli ampak pixli
uniform float texture_altitude = 5.0; // količina offseta ... višin texture

// dimenzija teksture za uskladitev texlov s pixli (1/texture original size)  
uniform float texture_width = 640.0;
uniform float texture_height = 360.0;



void fragment(){

	// preračun pravge offseta sence ... pixle konvertamo v texle
	vec2 shadow_offset = vec2(shadow_offset_x / texture_width, shadow_offset_y / texture_height);
	vec2 uvs = UV + shadow_offset * texture_altitude;
	
	// poberemo prikaz texture in apliciramo samo offset še predno apliciramo barvo 
	vec4 color = texture(TEXTURE, uvs);

	
	// manipuliramo izbrano barvo
	if (manipulate_other_colors == false){
		
		// če je barva texture enaka izbrani apliciramo efekt
		if (color == manipulate_color){
			color = shadow_color * color.a;
		}
		// druge barve so brez efekta
		else {
			color.a = 0.0; // 100% transparenca
			color = texture(TEXTURE, UV); // original barva in pozicija
		}
	}
	
	// manipuliramo vse razen izbrane barve
	else if (manipulate_other_colors == true){
		
		// če barva texture ni transparenta apliciramo efekt
		if (color.a > 0.0){
			
			// barva enaka izbrani barvi je brez efekta
			if (color == manipulate_color){
				color.a = 0.0;
				color = texture(TEXTURE, UV);
			}
			// aplciramo efekt na vse druge barve
			else {
				color = shadow_color * color.a;
			}
		}
		// barva transparentnega dela tekture
		else {
			color = transparent_to_color;
		}
		
	}
	
	COLOR = color;
}"

[sub_resource type="ShaderMaterial" id=26]
shader = SubResource( 25 )
shader_param/manipulate_color = Color( 0, 0, 0, 1 )
shader_param/manipulate_other_colors = false
shader_param/transparent_to_color = Color( 0, 0, 0, 0 )
shader_param/shadow_color = Color( 0, 0, 0, 0.27451 )
shader_param/shadow_offset_x = 0.0
shader_param/shadow_offset_y = 1.0
shader_param/texture_altitude = 12.0
shader_param/texture_width = 640.0
shader_param/texture_height = 360.0

[sub_resource type="ViewportTexture" id=38]
viewport_path = NodePath("Viewport Z-0")

[sub_resource type="Shader" id=27]
code = "shader_type canvas_item;

// šejder v1 - prepoznava 100% transparenco in aplicira novo barvo na te pixle
// šejder v2 - prepoznava tudi cutout barvo, ki jo potem manipulira
// šejder v3 - prepoznava barvo, ki ji mora dodat senco
// šejder v4 - prepoznava različne barve, ki jim dodaj različne sence
// šejder v5 - dodaja sence za prizemljene objekte

//... simple nadgradnja je če dodam več barv za manipulirat ... al pa celo gradient

// barve
uniform vec4 manipulate_color_1 : hint_color = vec4(1.0, 0.0, 0.0, 1.0); // select color to regirster and manipulate
uniform vec4 manipulate_color_2 : hint_color = vec4(0.0, 1.0, 0.0, 1.0); // select color to regirster and manipulate
uniform vec4 manipulate_color_3 : hint_color = vec4(0.0, 0.0, 1.0, 1.0); // select color to regirster and manipulate
uniform bool manipulate_other_colors = true;

// shadow
uniform vec4 shadow_color : hint_color = vec4(0.0, 0.0, 0.0, 1.0);
uniform float shadow_offset_x = 1.0; // smer offseta ... to niso texli ampak pixli
uniform float shadow_offset_y = 1.0; // smer offseta ... to niso texli ampak pixli
uniform float texture_altitude = 5.0; // količina offseta ... višin texture

uniform vec4 transparent_to_color : hint_color = vec4(0.0, 0.0, 0.0, 0.0); // apply color to texture with alpha 0.0

// dimenzija teksture za uskladitev texlov s pixli (1/texture original size)  
uniform float texture_width = 640.0;
uniform float texture_height = 360.0;



void fragment(){

	// preračun pravge offseta sence ... pixle konvertamo v texle
	vec2 shadow_offset = vec2(shadow_offset_x / texture_width, shadow_offset_y / texture_height);
	vec2 uvs = UV + shadow_offset * texture_altitude;
	
	// poberemo prikaz texture in apliciramo samo offset še predno apliciramo barvo 
	vec4 color = texture(TEXTURE, uvs);

	
	// manipuliramo izbrane barve
	if (manipulate_other_colors == false){
		
		// če je barva texture enaka izbrani apliciramo efekt
		if (color == manipulate_color_1){
			color = shadow_color * color.a;
		}
		else if (color == manipulate_color_2){
			color = shadow_color * color.a;
		}
		else if (color == manipulate_color_3){
			color = shadow_color * color.a;
		}
		
		
		
		
		// druge barve so brez efekta
		else {
			color.a = 0.0; // 100% transparenca
			color = texture(TEXTURE, UV); // original barva in pozicija
		}
	}
	
	// manipuliramo vse razen izbrane barve
	else if (manipulate_other_colors == true){
		
		// če barva texture ni transparenta apliciramo efekt
		if (color.a > 0.0){
			
			// barva enaka izbrani barvi je brez efekta
			if (color == manipulate_color_1){
				color.a = 0.0;
//				color = texture(TEXTURE, UV);
			}
			else if (color == manipulate_color_2){
				color.a = 0.0;
//				color = texture(TEXTURE, UV);
			}
			else if (color == manipulate_color_3){
				color.a = 0.0;
//				color = texture(TEXTURE, UV);
			}
			
			// aplciramo efekt na vse druge barve
			else {
				color = shadow_color * color.a;
			}
		}
		// barva transparentnega dela tekture
		else {
			color = transparent_to_color;
		}
		
	}
	
	COLOR = color;
}"

[sub_resource type="ShaderMaterial" id=24]
shader = SubResource( 27 )
shader_param/manipulate_color_1 = Color( 0, 1, 0, 1 )
shader_param/manipulate_color_2 = Color( 0, 0, 0, 1 )
shader_param/manipulate_color_3 = Color( 0, 0, 0, 0 )
shader_param/manipulate_other_colors = true
shader_param/shadow_color = Color( 0, 0, 0, 0.27451 )
shader_param/shadow_offset_x = 0.0
shader_param/shadow_offset_y = 1.0
shader_param/texture_altitude = 6.0
shader_param/transparent_to_color = Color( 0, 0, 0, 0 )
shader_param/texture_width = 640.0
shader_param/texture_height = 360.0

[sub_resource type="ViewportTexture" id=39]
viewport_path = NodePath("Viewport Z-0")

[sub_resource type="ShaderMaterial" id=31]
shader = ExtResource( 3 )
shader_param/manipulate_color_1 = Color( 1, 0, 0, 1 )
shader_param/new_color_1 = Color( 1, 1, 0, 1 )
shader_param/manipulate_color_2 = Color( 0, 1, 0, 1 )
shader_param/new_color_2 = Color( 1, 0.913725, 0, 1 )
shader_param/manipulate_color_3 = Color( 0, 0, 1, 1 )
shader_param/new_color_3 = Color( 1, 0, 1, 1 )
shader_param/manipulate_other = false
shader_param/new_color_other = Color( 0.5, 0.5, 0.5, 1 )
shader_param/transparent_to_color = Color( 0, 0, 0, 0 )

[sub_resource type="ViewportTexture" id=22]
viewport_path = NodePath("Viewport Z-0")

[node name="ViewContainer" type="ViewportContainer"]
margin_right = 640.0
margin_bottom = 360.0
rect_min_size = Vector2( 640, 360 )
stretch = true
script = ExtResource( 1 )

[node name="Background Z-3" type="Node2D" parent="."]
z_index = -3

[node name="ColorRect" type="ColorRect" parent="Background Z-3"]
margin_right = 640.0
margin_bottom = 360.0
rect_min_size = Vector2( 640, 360 )
color = Color( 0.054902, 0.709804, 0.498039, 1 )

[node name="Shadow_Level Z-2 - igranje" type="Sprite" parent="."]
visible = false
material = SubResource( 36 )
z_index = -2
texture = SubResource( 37 )
centered = false
flip_v = true

[node name="Shadow_Level Z-1" type="Sprite" parent="."]
visible = false
material = SubResource( 26 )
z_index = -1
texture = SubResource( 38 )
centered = false
flip_v = true

[node name="Shadow_Moving Objects Z-1" type="Sprite" parent="."]
visible = false
material = SubResource( 24 )
z_index = -1
texture = SubResource( 39 )
centered = false
flip_v = true

[node name="Effects Z-0" type="Sprite" parent="."]
material = SubResource( 31 )
texture = SubResource( 22 )
centered = false
flip_v = true

[node name="Light2D" type="Light2D" parent="."]
visible = false
position = Vector2( 287.5, 196.5 )
scale = Vector2( 6.51049, 3.72727 )
texture = ExtResource( 5 )

[node name="Viewport Z-0" type="Viewport" parent="."]
size = Vector2( 640, 360 )
transparent_bg = true
handle_input_locally = false
msaa = 2
fxaa = true
debanding = true
hdr = false
disable_3d = true
usage = 0
render_target_update_mode = 3

[node name="Arena" parent="Viewport Z-0" instance=ExtResource( 2 )]

[editable path="Viewport Z-0/Arena"]
[editable path="Viewport Z-0/Arena/Level_00"]
[editable path="Viewport Z-0/Arena/Player"]
