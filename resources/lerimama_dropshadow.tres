[gd_resource type="Shader" format=2]

[resource]
code = "shader_type canvas_item;
//render_mode blend_mix;



//uniform float color_outline_scale = 5.0; // Size of color outlines
uniform float max_edge_alpha : hint_range(0,1) = 0.5; // Max edge alpha, lower values means edges blend more with background
uniform float edge_alpha_multiplier = 3.0; // General multiplier for edge alpha value, higher values mean harder edges
uniform vec4 edge_color : hint_color; // Outlines color

uniform float offset_x = -0.005;
uniform float offset_y = -0.005;

void fragment() {
	
	// višina sence
//	float halfScaleFloor_c = floor(color_outline_scale * 0.5);
//	float halfScaleCeil_c = ceil(color_outline_scale * 0.5);
//	halfScaleFloor_c = 10.0;
//	halfScaleCeil_c = 10.0;
	
	
	vec2 ps = TEXTURE_PIXEL_SIZE; // velikost pixlov
	vec2 topUV = SCREEN_UV + vec2(offset_x, offset_y); // izračun zamika UV
//	vec2 centerUV_c = SCREEN_UV; // UV original teksture
	
	// izračun texture sence (barva in UV)
	vec4 top_tex = texture(TEXTURE, topUV);
	vec4 center_tex = texture(TEXTURE, SCREEN_UV);
//	vec4 bottom_tex = texture(TEXTURE, bottomUV_c);

	// mešanje barv
	vec4 col = top_tex;
	
	float color_edge;
	
	color_edge += col.r;
	color_edge += col.g;
	color_edge += col.b;
	color_edge /= 3.0;
//	color_edge *= col.a;
//	color_edge *= modulate;
	
//	color_edge += col.a; // transparenca ... 0.1 pomeni polno barvo
	
//	float edgeVal = color_edge;
	// preverimo kje je sprite transparenten
//	float edge_alpha = min(max_edge_alpha, edgeVal * edge_alpha_multiplier); 
	
	
// ---------------------------------------------------------------------------------

//	vec4 col = texture(TEXTURE, UV);
//	COLOR = mix(top_tex, center_tex, center_tex.a);

	// z mešanjem barve
	COLOR = (color_edge * edge_color.rgba) + texture(TEXTURE, SCREEN_UV).rgba;
//	COLOR = (color_edge * edge_color.rgba) + textura viewportsa.rgba;

//	vec4 shadow = vec4(edge_color.rgb, texture(TEXTURE, SCREEN_UV - vec2(offset_x,offset_y) * ps).a * edge_color.a);
//	col = texture(TEXTURE, SCREEN_UV);
//
//	COLOR = mix(shadow, col, col.a);



	
	// shader off
//	COLOR = texture(TEXTURE, SCREEN_UV);

	// A over B    
//	vec4 A = top_tex;
//	vec4 B = center_tex;
//	COLOR.a = A.a + (1.0 - A.a) * B.a;
//	COLOR.rgb = 1.0 / COLOR.a * (A.a * A.rgb + (1.0 - A.a) * B.a * B.rgb);

//	COLOR = mix(center_tex, top_tex, top_tex.a);

//	vec4 col = texture(TEXTURE, UV);
//	COLOR = mix(shadow, col, col.a);
}

// ORIG DŠ


//void fragment() {
//	vec2 ps = TEXTURE_PIXEL_SIZE * float(intensity) * precision;
//
//	vec4 shadow = vec4(modulate.rgb, texture(TEXTURE, UV - offset * ps).a * modulate.a);
//	vec4 col = texture(TEXTURE, UV);
//
//	COLOR = mix(shadow, col, col.a);
//}





// DRUGE SMERI
	
//	vec2 bottomUV_c = SCREEN_UV + vec2(1.0, -ps.y * halfScaleFloor_c);
//	vec2 bottomLeftUV_c = SCREEN_UV - vec2(texelSize.x, texelSize.y) * halfScaleFloor_c;
//	vec2 topRightUV_c = SCREEN_UV + vec2(texelSize.x, texelSize.y) * halfScaleCeil_c;
//	vec2 rightUV_c = SCREEN_UV + vec2(texelSize.x * halfScaleCeil_c, 0.0);
//	vec2 leftUV_c = SCREEN_UV + vec2(-texelSize.x * halfScaleFloor_c, 0.0);
//	vec2 bottomRightUV_c = SCREEN_UV + vec2(texelSize.x * halfScaleCeil_c, -texelSize.y * halfScaleFloor_c);
//	vec2 topLeftUV_c = SCREEN_UV + vec2(-texelSize.x * halfScaleFloor_c, texelSize.y * halfScaleCeil_c);
	
//	vec4 n0 = texture(TEXTURE, topLeftUV_c);
//	vec4 n1 = texture(TEXTURE, topUV_c);
//	vec4 n2 = texture(TEXTURE, topRightUV_c);
//	vec4 n3 = texture(TEXTURE, leftUV_c);
//	vec4 n4 = texture(TEXTURE, centerUV_c);
//	vec4 n5 = texture(TEXTURE, rightUV_c);
//	vec4 n6 = texture(TEXTURE, bottomLeftUV_c);
//	vec4 n7 = texture(TEXTURE, bottomUV_c);
//	vec4 n8 = texture(TEXTURE, bottomRightUV_c);
	
//	vec4 n0 = vec4(0.0);
//	vec4 n2 = vec4(0.0);
//	vec4 n3 = vec4(0.0);
//	vec4 n5 = vec4(0.0);
//	vec4 n6 = vec4(0.0);
//	vec4 n8 = vec4(0.0);
"
