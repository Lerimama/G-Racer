[gd_scene load_steps=4 format=2]

[ext_resource path="res://game/level/breakers/breaker/Breaker.tscn" type="PackedScene" id=1]
[ext_resource path="res://common/shadows/shadow_color_blur.material" type="Material" id=2]

[sub_resource type="GDScript" id=11922]
script/source = "extends Polygon2D


export (NodePath) var shadow_owner_shape_path: String
export var shadow_z_index: int = 0 # samo, če rabiš spcifičnega

var shadow_rotation_degrees: float setget _on_change_shadow_rotation # za animirano rotacijo ... v stopinjah, ker lažje setam
var shadow_owner_rotation: float
var caster_is_texture: bool = false

#onready var shadow_owner: Node2D = get_parent()
onready var shadow_owner: Node2D = get_parent()
onready var shadow_owner_shape: Node# = get_node(shadow_owner_shape_path) # poligon, sprite, texture_rect, texture_btn

# od ownerja, igre in obeh
onready var shadow_offset: float = shadow_owner.elevation
onready var shadow_direction: Vector2 = Refs.game_manager.shadows_direction_from_source.normalized() setget _on_direction_change
onready var shadow_color: Color = Refs.game_manager.shadows_color_from_source
onready var shadow_alpha: float = Refs.game_manager.shadows_alpha_from_source * shadow_owner.transparency # modulate.a
onready var shadow_length: float = (shadow_owner.height + shadow_offset) * Refs.game_manager.shadows_length_from_source


func _ready() -> void:

	add_to_group(Refs.group_shadows)

	# z index
	if shadow_z_index == 0:
		z_index = Pros.z_indexes[Refs.group_shadows]
	else:
		z_index = shadow_z_index

	# aktivate shadows
	if shadow_owner_shape_path:
		shadow_owner_shape = get_node(shadow_owner_shape_path)

	if not shadow_owner_shape:
		hide()
	else:
		shadow_owner_shape.connect(\"item_rect_changed\", self, \"_on_item_rect_changed\")
		if \"texture\" in shadow_owner_shape and not shadow_owner_shape is Polygon2D:
			caster_is_texture = true
		update_shadow()

func _on_item_rect_changed():
	print (\"item changed .............\")



func _process(delta: float) -> void: # preverjanje sprememb nekaterih lastnosti lastnika

	_detect_changes_on_owner()



func update_shadow(with_shape_update: bool = true):

	# pogrebam nove nastavitve
	shadow_offset = shadow_owner.elevation
	shadow_length = (shadow_owner.height + shadow_offset) * Refs.game_manager.shadows_length_from_source
	shadow_alpha = Refs.game_manager.shadows_alpha_from_source * shadow_owner.transparency
	shadow_color = Refs.game_manager.shadows_color_from_source

	if not shadow_owner_shape:
		# printerr (\"Shadow casting missing: \", self)
		hide()
	elif shadow_length == 0 or shadow_direction == Vector2.ZERO:
		hide()
	else:
		if with_shape_update:
			# če se shadow caster premakne ali resiza
			if caster_is_texture:
				_create_texture_shadow()
			else:
				_create_shadow_polygon()

			if shadow_owner_shape is Control:
				position = shadow_owner_shape.rect_position
				scale = shadow_owner_shape.rect_scale
			else:
				position = shadow_owner_shape.position
				scale = shadow_owner_shape.scale
			#			if \"centered\" in shadow_owner_shape:
			#				shadow_owner_shape.centered = false # OPT
		show()

	color = shadow_color
	modulate.a = shadow_alpha


func _create_shadow_polygon(base_shadow_casting_polygon: PoolVector2Array = shadow_owner_shape.polygon):
	# dupliciram original polygon in ga zamaknem
	# povežem sorodne pare točko med obema poligonoma v kvadrate
	# kvadrate združim z original obliko

	# casting poligon ... offsetan, če je owner dvignjen
	var new_shadow_casting_polygon: PoolVector2Array = []
	var shadow_offset_in_direction: Vector2 = shadow_direction * shadow_offset
	if shadow_offset == 0:
		new_shadow_casting_polygon = base_shadow_casting_polygon
	else:
		for point in base_shadow_casting_polygon:
			new_shadow_casting_polygon.append(point + shadow_offset_in_direction)

	# shadow poligon ... senčko
	var shadow_polygon: PoolVector2Array # zamaknjene original točke
	var shadow_length_in_direction: Vector2 = shadow_direction * shadow_length
	for point in base_shadow_casting_polygon:
		shadow_polygon.append(point + shadow_length_in_direction)

	# povežem točkovne pare casterja in senčke v kvadrate
	var square_polygons: Array = []
	for point_index in new_shadow_casting_polygon.size():
		var new_square_polygon: PoolVector2Array = []
		var next_point_index: int = point_index + 1
		if point_index == base_shadow_casting_polygon.size() - 1:
			next_point_index = 0
		new_square_polygon.append(new_shadow_casting_polygon[point_index])
		new_square_polygon.append(new_shadow_casting_polygon[next_point_index])
		new_square_polygon.append(shadow_polygon[next_point_index])
		new_square_polygon.append(shadow_polygon[point_index])
		square_polygons.append(new_square_polygon)

	# vsak kvadrat mergam s casterjem
	var merged_shadow: PoolVector2Array = new_shadow_casting_polygon
	for square in square_polygons:
		var merged_to_casting_polygon: Array = Geometry.merge_polygons_2d(merged_shadow, square)
		if not merged_to_casting_polygon.empty():
			merged_shadow = merged_to_casting_polygon[0]

	set_deferred(\"polygon\", merged_shadow)


func _create_texture_shadow():

	var new_shadow_polygons: Array = _get_polygons_from_texture()
	# dela samo z enim poligonom
	if new_shadow_polygons.size() == 1:
		_create_shadow_polygon(new_shadow_polygons[0])
	elif new_shadow_polygons.size() > 1:
		print(\"Texture shadow resulted in more than one polygon.\")
		hide()
	else: # empty
		print(\"Texture shadow resulted in ZERO polygons.\")
		hide()


func _get_polygons_from_texture():

	var transparency_image: Image = shadow_owner_shape.texture.get_data()
	var transparency_bitmap = BitMap.new()
	transparency_bitmap.create_from_image_alpha(transparency_image)
	var bitmap_rect: Rect2 = Rect2(Vector2.ZERO, transparency_bitmap.get_size())
	var bitmap_polygons: Array = transparency_bitmap.opaque_to_polygons(bitmap_rect) # polygons array (rect: Rect2, epsilon: float = 2.0)

	return bitmap_polygons


# DETECT OWNER CHANGE -----------------------------------------------------------------------------------------------


func _detect_changes_on_owner():

	# rotacija lastnika
	var prev_shadow_owner_rotation = shadow_owner_rotation
	shadow_owner_rotation = shadow_owner.rotation
	# če je sprememba v rotaciji apdejtam senčko
	if not shadow_owner_rotation == prev_shadow_owner_rotation:
		_on_change_owner_rotation(shadow_owner_rotation - prev_shadow_owner_rotation)


func _on_change_owner_rotation(owner_rotation_change: float): # owner setting

	shadow_direction = shadow_direction.rotated(- owner_rotation_change)
	update_shadow()


#func _on_change_owner_elevation(new_owner_elevation: float): # owner setting
#
#	shadow_offset = new_owner_elevation
#	# apdejtam tudi dolžino
#	shadow_length = (shadow_owner.height + shadow_offset) * Refs.game_manager.shadows_length_from_source
#	update_shadow()
#
#
#func _on_change_owner_height(new_owner_height: float): # owner setting
#
#	shadow_length = (new_owner_height + shadow_offset) * Refs.game_manager.shadows_length_from_source
#	update_shadow()
#
#
#func _on_change_owner_transparency(new_owner_transparency: float): # owner setting
#
#	shadow_alpha = Refs.game_manager.shadows_alpha_from_source * new_owner_transparency
#	update_shadow()


# SETGET CHANGE -----------------------------------------------------------------------------------------------


func _on_direction_change(new_direction: Vector2): # game setting

	shadow_direction = new_direction.normalized()
	update_shadow()


func _on_change_shadow_rotation(new_rotation: float): # game setting

	shadow_rotation_degrees = new_rotation
	shadow_direction = Vector2.RIGHT.rotated(deg2rad(shadow_rotation_degrees))
	update_shadow()


#func _on_change_shadow_color(new_color: Color): # game setting
#
#	shadow_color = new_color
#	color = shadow_color
#	update_shadow()
"

[node name="BreakerConcrete" instance=ExtResource( 1 )]

[node name="PolygonShadow" parent="." index="1"]
material = ExtResource( 2 )
polygon = PoolVector2Array( 0, 64, 64, 64, 64, 0, 0, 0 )
script = SubResource( 11922 )

[node name="BreakerBase" parent="." index="2"]
texture_scale = Vector2( 5, 5 )
