[gd_scene load_steps=56 format=2]

[ext_resource path="res://game/GameView.tscn" type="PackedScene" id=1]
[ext_resource path="res://game/Game.gd" type="Script" id=2]
[ext_resource path="res://game/gui/GameOver.tscn" type="PackedScene" id=3]
[ext_resource path="res://assets/sounds/music/nitro_music.mp3" type="AudioStream" id=4]
[ext_resource path="res://assets/sounds/sfx/_pa/burst/burst.wav" type="AudioStream" id=5]
[ext_resource path="res://assets/sounds/sfx/_pa/gui/key_2.wav" type="AudioStream" id=6]
[ext_resource path="res://game/gui/PauseGame.tscn" type="PackedScene" id=7]
[ext_resource path="res://game/gui/hud/Hud.tscn" type="PackedScene" id=8]
[ext_resource path="res://assets/sounds/sfx/_pa/gui/key_3.wav" type="AudioStream" id=9]
[ext_resource path="res://game/gui/AgentHuds.gd" type="Script" id=10]
[ext_resource path="res://assets/sounds/music/moose.mp3" type="AudioStream" id=11]
[ext_resource path="res://game/gui/AgentHud.tscn" type="PackedScene" id=12]
[ext_resource path="res://game/gui/LevelFinished.tscn" type="PackedScene" id=13]
[ext_resource path="res://assets/sounds/sfx/misile_flight.wav" type="AudioStream" id=14]
[ext_resource path="res://assets/sounds/music/Ludum Dare 28 - Track 1_loop.wav" type="AudioStream" id=15]
[ext_resource path="res://assets/sounds/sfx/race_start_beep___f1-starting-lights-sound-download_audio_best.wav" type="AudioStream" id=16]
[ext_resource path="res://assets/sounds/sfx/misile_shoot.wav" type="AudioStream" id=17]
[ext_resource path="res://assets/sounds/sfx/misile_hit.wav" type="AudioStream" id=18]
[ext_resource path="res://assets/sounds/_zaloga/detect_ping___383147__jomellejager__alarm.wav" type="AudioStream" id=19]
[ext_resource path="res://assets/sounds/sfx/_pa/gui/screen_slide.wav" type="AudioStream" id=20]
[ext_resource path="res://assets/sounds/sfx/_pa/gui/menu_fade.wav" type="AudioStream" id=21]
[ext_resource path="res://game/SoundManagerGame.gd" type="Script" id=22]
[ext_resource path="res://assets/sounds/sfx/bullet_shoot___658823__3dj__battlefield-7.wav" type="AudioStream" id=23]
[ext_resource path="res://assets/sounds/sfx/shocker_efekt___PA_skilled_frcer.wav" type="AudioStream" id=24]
[ext_resource path="res://assets/sounds/sfx/weapon_reload___432141__maximbomba__rifle-or-shotgun-reload.wav" type="AudioStream" id=25]
[ext_resource path="res://assets/sounds/sfx/pickup___39026__wildweasel__keypickup.wav" type="AudioStream" id=27]
[ext_resource path="res://assets/sounds/sfx/nitro_short___491407__samsterbirdies__jet-engine-startup.wav" type="AudioStream" id=28]
[ext_resource path="res://assets/sounds/sfx/_pa/events/win_jingle_270528__littlerobotsoundfactory__jingle_win_00.wav" type="AudioStream" id=29]
[ext_resource path="res://assets/sounds/sfx/hit_stray_v2.wav" type="AudioStream" id=31]
[ext_resource path="res://assets/sounds/sfx/hit_wall.wav" type="AudioStream" id=32]
[ext_resource path="res://assets/sounds/sfx/hit_explosion2___677934__logicogonist__explosion-4.wav" type="AudioStream" id=33]
[ext_resource path="res://assets/sounds/sfx/finish_horn_217138__lonemonk__1964-chrysler-horn-honk-short.wav" type="AudioStream" id=34]
[ext_resource path="res://assets/sounds/sfx/_pa/burst/burst_cocking_short.wav" type="AudioStream" id=35]
[ext_resource path="res://assets/sounds/sfx/_pa/gui/btn_confirm_NFF-home-switch-on.wav" type="AudioStream" id=36]
[ext_resource path="res://assets/sounds/sfx/_pa/skills/teleport_loop_v2.wav" type="AudioStream" id=37]
[ext_resource path="res://assets/sounds/sfx/_pa/gui/btn_focus_change.wav" type="AudioStream" id=38]
[ext_resource path="res://assets/sounds/sfx/_pa/burst/burst_uncocking.wav" type="AudioStream" id=39]
[ext_resource path="res://assets/sounds/sfx/_pa/skills/teleport_in_v2.wav" type="AudioStream" id=40]
[ext_resource path="res://assets/sounds/sfx/_pa/skills/skill_cling.wav" type="AudioStream" id=41]
[ext_resource path="res://assets/sounds/sfx/_pa/skills/teleport_out_v2.wav" type="AudioStream" id=42]
[ext_resource path="res://assets/sounds/sfx/_pa/events/countdown-a.ogg" type="AudioStream" id=46]
[ext_resource path="res://assets/sounds/sfx/_pa/gui/key_5.wav" type="AudioStream" id=47]
[ext_resource path="res://assets/sounds/sfx/_pa/gui/btn_cancel_NFF-home-switch-off.wav" type="AudioStream" id=48]
[ext_resource path="res://assets/sounds/sfx/_pa/gui/tutorial_stage_a_NFF-glocken-bad.wav" type="AudioStream" id=53]
[ext_resource path="res://assets/sounds/sfx/_pa/gui/key_1.wav" type="AudioStream" id=60]
[ext_resource path="res://assets/sounds/sfx/_pa/gui/key_4.wav" type="AudioStream" id=61]
[ext_resource path="res://assets/sounds/sfx/_pa/events/loose_jingle_GAMEOVER.wav" type="AudioStream" id=65]
[ext_resource path="res://assets/sounds/music/Patreon Goal Reward Loops - Track 08_loop.wav" type="AudioStream" id=66]
[ext_resource path="res://assets/sounds/music/457363__3m4__trap-beat-2.mp3" type="AudioStream" id=68]

[sub_resource type="GDScript" id=20]
script/source = "extends Node
#
#
#signal bolt_spawned (name, other)
#signal game_state_changed (game_on, level_profile)
#
#var game_on: bool
#
#var agents_in_game: Array # live data ... tekom igre so v ranked zaporedju (glede na distanco)
#var agents_finished: Array # bolti v cilju
#var players_qualified: Array # obstaja za prenos med leveloma
#var camera_leader: Node2D setget _change_camera_leader # trenutno vodilni igralec ... lahko tudi kakšen drug pogoj
#
## game
##var game_settings: Dictionary # set_game seta iz profilov
#var activated_drivers: Array # naslednji leveli se tole adaptira, glede na to kdo je še v igri
#var fast_start_window: bool = false # bolt ga čekira in reagira
#var start_position_nodes: Array # dobi od tilemapa
#var current_pull_positions: Array # že zasedene pozicije za preventanje nalaganja bolto druga na drugega
#
## level
#var level_profile: Dictionary # set_level seta iz profilov
#var current_level_index = 0
#var available_pickable_positions: Array # za random spawn
#var navigation_positions: Array # pozicije vseh navigation tiletov
#var pickables_in_game: Array
#
#onready var level_finished_ui: Control = $\"../UI/LevelFinished\"
#onready var game_over_ui: Control = $\"../UI/GameOver\"
#
## shadows
##onready var game_shadows_direction: Vector2 = Sts.game_shadows_direction # Vector2(1, 1) # set_game seta iz profilov
#onready var game_shadows_length_factor: float = Sts.game_shadows_length_factor # set_game seta iz profilov
#onready var game_shadows_alpha: float = Sts.game_shadows_alpha # set_game seta iz profilov
#onready var game_shadows_color: Color = Sts.game_shadows_color # set_game seta iz profilov
#onready var game_shadows_rotation_deg: float = Sts.game_shadows_rotation_deg # set_game seta iz profilov
#
## neu
#var games
#onready var hud: Control = $\"../UI/Hud\"
#onready var pause_game: Control = $\"../UI/PauseGame\"
#onready var level_finished: Control = $\"../UI/LevelFinished\"
#onready var game_over: Control = $\"../UI/GameOver\"
#onready var game_view: ViewportContainer = $\"../GameViewFlow/GameView\"
#var level_stats: Dictionary = {} # napolnem na spawn bolt
#var goals_to_reach: Array = []
#var current_level_brez_reference: Node2D
#
##var level: Level
#onready var current_level: Level# = Rfs.current_level
#
#
#func _input(event: InputEvent) -> void:
#
#
#	if Input.is_action_just_pressed(\"no1\"):
#		get_tree().set_group(Rfs.group_shadows, \"imitate_3d\", true)
#	elif Input.is_action_just_pressed(\"no2\"):
#		get_tree().set_group(Rfs.group_shadows, \"imitate_3d\", false)
#	elif Input.is_action_just_pressed(\"no3\"):
#		_animate_day_night()
#
#
#func _ready() -> void:
##	printt(\"GM\")
#
#	Rfs.game_manager = self
#
#	# intro:
#	get_parent().modulate = Color.black
#
#	call_deferred(\"_set_game\")
#
#
#func _process(delta: float) -> void:
#
#	agents_in_game = get_tree().get_nodes_in_group(Rfs.group_agents)
#	pickables_in_game = get_tree().get_nodes_in_group(Rfs.group_pickables)
#
#	_update_ranking()
#
#	# camera leader
#	for bolt in agents_in_game:
#		if bolt.is_in_group(Rfs.group_players) and bolt.is_active:
#			self.camera_leader = bolt
#			break
#		self.camera_leader = null
#		printt (\"LS\", level_stats[bolt.driver_index][Pfs.STATS.GOALS_REACHED])
#
#
#func _change_camera_leader(new_camera_leader: Node2D):
#
#	if new_camera_leader == camera_leader:
#		pass
#	elif new_camera_leader == null:
#		pass
#	else:
#		camera_leader = new_camera_leader
#		Rfs.game_camera.follow_target = camera_leader
#
#
#func _set_game():
#
#	_spawn_level()
#	yield(get_tree(), \"idle_frame\") # zazih ... na levelu bazira vse ostalo
#
#	hud.setup(level_profile) # kliče GM
#	Rfs.game_camera.follow_target = current_level.start_camera_position_node
#
#	# playing field
#	var playing_field_node: Node2D = Rfs.game_camera.playing_field
#	playing_field_node.connect( \"body_exited_playing_field\", self, \"_on_body_exited_playing_field\")
#	if Sts.all_agents_on_screen_mode:
#		if level_profile[\"level_type\"] == Pfs.BASE_TYPE.TIMED:
#			playing_field_node.enable_playing_field(true)
#		else:
#			playing_field_node.enable_playing_field(true, true) # z edgom
#	else:
#		playing_field_node.enable_playing_field(false)
#
#	# drivers
#	activated_drivers.clear()
#	if current_level_index == 0:
#		# če je prvi level so aktivirani dodani v meniju
#		printt(\"GM\", Sts.drivers_on_game_start)
#		activated_drivers = Sts.drivers_on_game_start
#	else: # če ni prvi level dodam kvalificirane driver_id
#		if players_qualified.empty():
#			print(\"Error! Ni qvalificiranih boltov, torej igre nebi smelo biti!\")
#		for bolt in players_qualified:
#			activated_drivers.append(bolt.driver_index)
#	players_qualified.clear()
#	#	printt(\"DRIVER_ID\", activated_drivers)
#
#	# AI
##	if Sts.enemies_mode: # začasno vezano na Set. filet
##		# za vsako prazno pozicijo dodam AI driver_id
##		var empty_positions_count = start_position_nodes.size() - activated_drivers.size()
##		empty_positions_count = 1 # debug ... omejitev  ai spawna na 1
##		for empty_position in empty_positions_count:
##			# dobim štartni id bolta in umestim ai data
##			var new_driver_index: int = activated_drivers.size()
##			var new_driver_id: int = Pfs.driver_profiles.keys()[new_driver_index]
##			Pfs.driver_profiles[new_driver_id][\"controller_type\"] = Pfs.ai_profile[Pfs.AI_TYPE.DEFAULT][\"controller_type\"]
##			activated_drivers.append(new_driver_id) # da prepoznam v spawn funkciji .... trik pač
#
#	# spawn bolts ... po vrsti aktivacije
#	var spawned_position_index = 0
#	print(\"activated_drivers\", activated_drivers)
#	for driver_index in activated_drivers: # so v ranking zaporedju
#		_spawn_bolt(driver_index, spawned_position_index) # scena, pozicija, profile id (barva, ...)
#		spawned_position_index += 1
#	Rfs.ultimate_popup.hide()
#	_game_intro()
#
#
#func _game_intro():
#
#	# pokažem sceno
#	var fade_time: float = 1
#	var setup_delay: float = 0 # delay, da se kamera naštima
#	var fade_tween = get_tree().create_tween()
#	fade_tween.tween_property(get_parent(), \"modulate\", Color.white, fade_time).from(Color.black).set_delay(setup_delay)
#	yield(fade_tween, \"finished\")
#
#	# bolts drive-in
#	var drive_in_time: float = 2
#	for bolt in agents_in_game:
#		var drive_in_vector: Vector2 = current_level.drive_in_position.rotated(current_level.level_start.global_rotation)
#		bolt.drive_in(drive_in_time, drive_in_vector)
#	yield(get_tree().create_timer(drive_in_time),\"timeout\")
#
#	_start_game()
#
#
#func _start_game():
#
#	# start countdown
#	if Sts.start_countdown and level_profile[\"level_type\"] == Pfs.BASE_TYPE.TIMED:
#		current_level.start_lights.start_countdown() # če je skrit, pošlje signal takoj
#		yield(current_level.start_lights, \"countdown_finished\")
#
#	Rfs.sound_manager.play_music()
#	hud.on_game_start()
#
#	# random pickables spawn
#	if level_profile[\"level_type\"] == Pfs.BASE_TYPE.UNTIMED:
#		_spawn_random_pickables()
#
#	game_on = true
#	emit_signal(\"game_state_changed\", game_on, level_profile) #  poslušajo drajverji,  hud3 \"signal dobijo\"
#
#	# fast start
#	fast_start_window = true
#	yield(get_tree().create_timer(Sts.fast_start_window_time), \"timeout\")
#	fast_start_window = false
#
#
#func end_level():
#
#	Rfs.game_camera.follow_target = current_level.finish_camera_position_node
#
#	if game_on:
#
#		game_on = false
#		emit_signal(\"game_state_changed\", game_on, level_profile) #  poslušajo drajverji,  hud3 \"signal dobijo\"
#
#		hud.on_level_finished()
#
#		yield(get_tree().create_timer(Sts.get_it_time), \"timeout\")
#
#		# preverim, če je kakšen človek kvalificiran
#		if agents_finished.empty():
#			pass
#		else:
#			# SUCCESS če je vsaj en plejer bil čez ciljno črto
#			for bolt in agents_finished:
#				if bolt.is_in_group(Rfs.group_players):
#					players_qualified.append(bolt)
#			# FAIL, če ni nobenega plejerja v cilju
#
#		var level_goal_reached: bool
#		if players_qualified.empty():
#			level_goal_reached = false
#
#		if level_goal_reached:
#			# ranking ob koncu levela
#			var bolts_ranked_on_level_finished: Array = []
#			# najprej dodam bolts finished, ki je že pravilno rangiran
#			bolts_ranked_on_level_finished.append_array(agents_finished)
#			# potem dodam še not finished ... po vrsti gre čez array in upošteva pogoje > vrstni red je po prevoženi distanci
#			for bolt in agents_in_game:
#				if not agents_finished.has(bolt):
#					bolts_ranked_on_level_finished.append(bolt)
#					if bolt.is_in_group(Rfs.group_ai):
#						# AI se vedno uvrsti in dobi nekaj časa glede na zadnjega v cilju
#						var worst_time_among_finished: float = agents_finished[agents_finished.size() - 1].driver_stats[Pfs.STATS.LEVEL_TIME]
#						bolt.driver_stats[Pfs.STATS.LEVEL_TIME] = worst_time_among_finished + worst_time_among_finished / 5
#						agents_finished.append(bolt)
#					elif bolt.is_in_group(Rfs.group_players):
#						# plejer se na Easy_mode uvrsti brez časa
#						if Sts.easy_mode:
#							agents_finished.append(bolt)
#
#			# je level zadnji?
#			if current_level_index < (Sts.current_game_levels.size() - 1):
#				level_finished_ui.open_level_finished(agents_finished, agents_in_game)
#			else:
#				game_over_ui.open_gameover(agents_finished, agents_in_game)
#				print(\"agents_finished\", agents_finished)
#
#		else:
#			print(\"agents_finished else \", agents_finished)
#			game_over_ui.open_gameover(agents_finished, agents_in_game)
#			#		var fade_time = 1
#			#		var fade_in_tween = get_tree().create_tween()
#			#		fade_in_tween.tween_property(get_parent(), \"modulate\", Color.black, fade_time)
#			#		yield(fade_in_tween, \"finished\")
#
#
#		for bolt in agents_in_game: # zazih
#			# driver se deaktivira, ko mu zmanjka bencina (in ko gre čez cilj)
#			# AI se deaktivira, ko gre čez cilj
#			if bolt.is_active: # zazih
#				bolt.is_active = false
#			bolt.set_physics_process(false)
#
#		# music stop
#		Rfs.sound_manager.stop_music()
#		# sfx mute
#		var bus_index: int = AudioServer.get_bus_index(\"GameSfx\")
#		AudioServer.set_bus_mute(bus_index, true)
#
#		# best lap stats reset
#		# looping sounds stop
#		# navigacija AI
#		# kvefri elementov, ki so v areni
#
#
#func set_next_level():
#
#	current_level_index += 1
#
#	agents_finished = [] # resetiram šele tukaj, ker ga rabim tudi v GO
#
#	# unmute sfx
#	if not Rfs.sound_manager.sfx_set_to_mute:
#		var bus_index: int = AudioServer.get_bus_index(\"GameSfx\")
#		AudioServer.set_bus_mute(bus_index, false)
#
#	# zbrišem vse otroke v NCP (bolti, orožja, efekti, ...)
#	var all_children: Array = Rfs.node_creation_parent.get_children()
#	for child in all_children:
#		child.queue_free()
#
#	# reset level values
#	self.camera_leader = null # trenutno vodilni igralec (rabim za camera target in pull target)
#
#	call_deferred(\"_set_game\")
#
#
## TRACKING ---------------------------------------------------------------------------------------------
#
#
#func _update_ranking():
#
#	if level_profile[\"level_type\"] == Pfs.BASE_TYPE.TIMED and current_level.level_track:
#		# najprej sortirami po poziciji trackerja,
#		# potem naredim array boltov v istem zaporedju
#		# potem razporedim array boltov glede na kroge
#		var bolts_ranked: Array = []
#		var all_bolt_trackers: Array = current_level.level_track.get_children()
#		all_bolt_trackers.sort_custom(self, \"_sort_trackers_by_offset\")
#		for bolt_tracker in all_bolt_trackers:
#			bolts_ranked.append(bolt_tracker.tracking_target)
#		bolts_ranked.sort_custom(self, \"_sort_bolts_by_laps\")
#		agents_in_game = bolts_ranked
#	else:
#		agents_in_game.sort_custom(self, \"_sort_trackers_by_points\")
#
#	for bolt in agents_in_game:
#		var current_bolt_rank: int = agents_in_game.find(bolt) + 1
#		if not current_bolt_rank == level_stats[bolt.driver_index][Pfs.STATS.LEVEL_RANK]:
#			level_stats[bolt.driver_index][Pfs.STATS.LEVEL_RANK] = current_bolt_rank
#			hud.update_bolt_level_stats(bolt.driver_index, Pfs.STATS.LEVEL_RANK, current_bolt_rank) # OPT prepogosto
#
#
#func _pull_bolt_on_field(bolt_to_pull: Bolt):
#
#	if game_on and Sts.all_agents_on_screen_mode:
#
#		if bolt_to_pull.is_active:
#
#			var bolt_pull_position: Vector2 = _get_bolt_pull_position(bolt_to_pull)
#			bolt_to_pull.call_deferred(\"pull_bolt_on_screen\", bolt_pull_position)
#
#			# če preskoči ciljno črto jo dodaj, če jo je leader prevozil
#			var pulled_bolt_level_stats: Dictionary = level_stats[bolt_to_pull.driver_index]
#			var leader_bolt_level_stats: Dictionary = level_stats[camera_leader.driver_index]
#
#			# poenotim level goals/laps stats ... če ni pulan točno preko cilja, pa bi moral bit
#			if pulled_bolt_level_stats[Pfs.STATS.LAPS_FINISHED].size() < leader_bolt_level_stats[Pfs.STATS.LAPS_FINISHED].size():
#				pulled_bolt_level_stats[Pfs.STATS.LAPS_FINISHED] = leader_bolt_level_stats[Pfs.STATS.LAPS_FINISHED]
#			# mogoče tega spodej nebi mel ... bomo videlo po testu
#			if pulled_bolt_level_stats[Pfs.STATS.GOALS_REACHED].size() < leader_bolt_level_stats[Pfs.STATS.GOALS_REACHED].size():
#				pulled_bolt_level_stats[Pfs.STATS.GOALS_REACHED] = leader_bolt_level_stats[Pfs.STATS.GOALS_REACHED]
#
#
#func _get_bolt_pull_position(bolt_to_pull: Bolt):
#	# na koncu izbrana pull pozicija:
#	# - je na območju navigacije
#	# - upošteva razdaljo do vodilnega
#	# - se ne pokriva z drugim plejerjem
#	#	printt (\"current_pull_positions\",current_pull_positions.size())
#	if game_on:
#
#		# pull pozicija brez omejitev
#		var pull_position_distance_from_leader: float = 200 # pull razdalja od vodilnega plejerja
#		var pull_position_distance_from_leader_correction: float = bolt_to_pull.chassis.get_node(\"BoltScale\").rect_size.x * 2 # 18 ... 20 # pull razdalja od vodilnega plejerja glede na index med trenutno pulanimi
#
#		var vector_to_leading_player: Vector2 = camera_leader.global_position - bolt_to_pull.global_position
#		var vector_to_pull_position: Vector2 = vector_to_leading_player - vector_to_leading_player.normalized() * pull_position_distance_from_leader
#		var bolt_pull_position: Vector2 = bolt_to_pull.global_position + vector_to_pull_position
#
#		# implementacija omejitev, da ni na steni ali elementu ali drugemu plejerju
#		var navigation_position_as_pull_position: Vector2
#		var available_navigation_pull_positions: Array
#
#		# poiščem navigacijsko celico, ki je najbližje določeni pull poziciji
#		for cell_position in navigation_positions:
#			# prva nav celica v preverjanju se opredeli kot trenutno najbližja
#			if navigation_position_as_pull_position == Vector2.ZERO:
#				navigation_position_as_pull_position = cell_position
#			# ostale nav celice ... če je boljša, jo določim za novo opredeljeno
#			else:
#				# preverim, če je bližja od trenutno opredeljene ... itak da je
#				if cell_position.distance_to(bolt_pull_position) < navigation_position_as_pull_position.distance_to(bolt_pull_position):
#					# pozicija je dovolj stran od vodilnega
#					if cell_position.distance_to(camera_leader.global_position) > pull_position_distance_from_leader:
#						# če je pozicija zasedena
#						if current_pull_positions.has(cell_position):
#							var pull_pos_index: int = current_pull_positions.find(cell_position)
#							var corrected_pull_position = pull_position_distance_from_leader + pull_pos_index * pull_position_distance_from_leader_correction
#							if cell_position.distance_to(camera_leader.global_position) > corrected_pull_position:
#								navigation_position_as_pull_position = cell_position
#						else: # če je poza zasedena dobim njen in dex med zasedenimi dodam korekcijo na zahtevani razdalji od vodilnega
#							navigation_position_as_pull_position = cell_position
#
#		current_pull_positions.append(navigation_position_as_pull_position) # OBS trenutno ne rabim
#
#		return navigation_position_as_pull_position
#
#
## SPAWNING ---------------------------------------------------------------------------------------------
#
#
#func _spawn_level():
#
#	# level name (iz seznama levelov v igri)
#	var level_to_load_id: int = Sts.current_game_levels[current_level_index]
#	var level_spawn_parent: Node = game_view.get_node(\"Viewport\") # VP node
##	var level_spawn_parent: Node = Rfs.game_camera.get_parent()
#
#	# level settings
#	level_profile = Pfs.level_profiles[level_to_load_id]
#	var level_to_load_path: String = level_profile[\"level_path\"]
#
#	var level_z_index: int # z index v node drevesu
#	if not current_level == null: # če level že obstaja, ga najprej moram zbrisat
#		level_z_index = current_level.z_index
#		current_level.set_physics_process(false)
#		current_level.free()
#
#	# spawn level
#	var NewLevel: PackedScene = ResourceLoader.load(level_to_load_path)
#	var new_level = NewLevel.instance()
#	new_level.z_index = level_z_index
#	new_level.connect( \"level_is_set\", self, \"_on_level_is_set\") # nujno pred add child, ker ga level sproži že na ready
#	level_spawn_parent.add_child(new_level)
#	level_spawn_parent.move_child(new_level, 0)
#
#	current_level = new_level
#	# connect elements: start, finish, goals
#	for node_path in current_level.level_goals_paths:
#		current_level.get_node(node_path).connect(\"reached_by\", self, \"_on_bolt_reached_goal\")
#		goals_to_reach.append(current_level.get_node(node_path))
#
#	if current_level.level_finish_path:
#		current_level.get_node(current_level.level_finish_path).connect(\"reached_by\", self, \"_on_finish_line_crossed\")
#
##	emit_signal()
#	#	print (\"spawned level_stats\", level_stats)
#
#
#func _spawn_bolt(bolt_driver_index: int, spawned_position_index: int):
#
#	var agent_type: int = Pfs.driver_profiles[bolt_driver_index][\"agent_type\"]
#	# debug ... ai spawn
#	var scene_name: String = \"agent_scene\"
##	if Pfs.driver_profiles[bolt_driver_index][\"controller_type\"] == Pfs.CONTROLLER_TYPE.AI:
##		scene_name = \"bolt_scene_ai\"
#	var NewBoltInstance: PackedScene = Pfs.bolt_profiles[agent_type][scene_name]
#
#	var new_bolt = NewBoltInstance.instance()
#	new_bolt.driver_index = bolt_driver_index
#	new_bolt.modulate.a = 0 # za intro
#	new_bolt.rotation_degrees = current_level.level_start.rotation_degrees - 90 # ob rotaciji 0 je default je obrnjen navzgor
#	new_bolt.global_position = start_position_nodes[spawned_position_index].global_position
#
#	# setam mu profile ... iz njih podatke povleče sam na readi
#	new_bolt.driver_profile = Pfs.driver_profiles[bolt_driver_index].duplicate()
#	new_bolt.driver_stats = Pfs.start_agent_stats.duplicate()
#	new_bolt.bolt_profile = Pfs.bolt_profiles[agent_type].duplicate()
#	Rfs.node_creation_parent.add_child(new_bolt)
#
#	# AI
#	if Pfs.driver_profiles[bolt_driver_index][\"driver_type\"] == Pfs.DRIVER_TYPE.AI:
#		new_bolt.bolt_controller.level_navigation = current_level.level_navigation
#		self.connect(\"game_state_changed\", new_bolt.bolt_controller, \"_on_game_state_change\") # _temp _on_game_state_change signal na ai
#
#	# race and goals
#	if current_level.level_track:
#		new_bolt.bolt_tracker = current_level.level_track.set_new_tracker(new_bolt)
#	new_bolt.bolt_controller.goals_to_reach = level_profile[\"level_goals\"].duplicate()
#
#	# signali
#	new_bolt.connect(\"bolt_activity_changed\", self, \"_on_bolt_activity_change\")
#	new_bolt.connect(\"bolt_stat_changed\", hud, \"_on_bolt_stat_changed\")
#
#	# bolts level stats
#	level_stats[bolt_driver_index] = Pfs.start_gent_level_stats.duplicate()
#	level_stats[bolt_driver_index][Pfs.STATS.LAPS_FINISHED] = [] # prepišem array v slovarju, da je tudi ta unique
#	level_stats[bolt_driver_index][Pfs.STATS.GOALS_REACHED] = []
#
#
#	emit_signal(\"bolt_spawned\", new_bolt, level_stats[bolt_driver_index]) # zaenkrat samo HUD, da prižge in napolne statbox
#
#
#func _spawn_random_pickables():
#
#	if available_pickable_positions.empty():
#		return
#
#	if pickables_in_game.size() <= Sts.pickables_count_limit - 1:
#
#		# žrebanje tipa
#		var random_pickable_key = Pfs.pickable_profiles.keys().pick_random()
#		var random_cell_position: Vector2 = navigation_positions.pick_random()
#		current_level.spawn_pickable(random_cell_position, \"random_pickable_key\", random_pickable_key)
#
#		# odstranim celico iz arraya tistih na voljo
#		var random_cell_position_index: int = available_pickable_positions.find(random_cell_position)
#		available_pickable_positions.remove(random_cell_position_index)
#
#	# random timer reštart
#	var random_pickable_spawn_time: int = [1, 2, 3].pick_random()
#	yield(get_tree().create_timer(random_pickable_spawn_time), \"timeout\") # OPT ... uvedi node timer
#
#	_spawn_random_pickables()
#
#
## UTILITI ---------------------------------------------------------------------------------------------
#
#
#func _animate_day_night():
#
#	var day_length: float = 10
#	var day_start_direction: Vector2 = Vector2.LEFT
#
#	var day_night_tween = get_tree().create_tween()
#	for shadow in get_tree().get_nodes_in_group(Rfs.group_shadows):
#		if shadow is Polygon2D:
#			day_night_tween.parallel().tween_property(shadow, \"shadow_rotation_deg\", 0, day_length).from(-180).set_ease(Tween.EASE_IN_OUT)
#
#
#func _sort_bolts_by_laps(bolt_1, bolt_2): # descending ... večji index je boljši
#	# For two elements a and b, if the given method returns true, element b will be after element a in the array.
#
#	var bolt_1_lap_count = level_stats[bolt_1.driver_index][Pfs.STATS.LAPS_FINISHED].size()
#	var bolt_2_lap_count = level_stats[bolt_2.driver_index][Pfs.STATS.LAPS_FINISHED].size()
#	if bolt_1_lap_count > bolt_2_lap_count:
#	    return true
#	return false
#
#
#func _sort_trackers_by_offset(bolt_tracker_1, bolt_tracker_2):# descending ... večji index je boljši
#	# For two elements a and b, if the given method returns true, element b will be after element a in the array.
#
#	if bolt_tracker_1.offset > bolt_tracker_2.offset:
#	    return true
#	return false
#
#
#func _sort_trackers_by_points(bolt_1, bolt_2):# descending ... večji index je boljši
#	# For two elements a and b, if the given method returns true, element b will be after element a in the array.
#
#	var bolt_1_points = bolt_1.driver_stats[Pfs.STATS.POINTS]
#	var bolt_2_points = bolt_2.driver_stats[Pfs.STATS.POINTS]
#	if bolt_1_points > bolt_2_points:
#	    return true
#	return false
#
#
#func _sort_trackers_by_speed(bolt_1, bolt_2): # temp ...  ne uporabljam# descn ... večji index je boljši
#
#	if bolt_1.velocity.length() > bolt_2.velocity.length():
#	    return true
#	return false
#
#
## SIGNALI ----------------------------------------------------------------------------------------------------
#
#
#func _on_bolt_reached_goal(goal_reached: Node, bolt_reaching: Bolt): # level poveže
#
#	print (\"reached\")
#	if game_on:
#		# reagira bolt in vrne, če ima še kakšen cilj (šteje tudi finish)
#		var bolt_level_stats: Dictionary = level_stats[bolt_reaching.driver_index]
#		bolt_level_stats[Pfs.STATS.GOALS_REACHED].append(goal_reached)
#
#		# če je bil na vrsti ga odštejem
#		if current_level.reach_goals_in_sequence:
#			if goal_reached == bolt_reaching.goals_to_reach[0]:
#				bolt_level_stats[Pfs.STATS.GOALS_REACHED].append(goal_reached)
#		else:
#			bolt_level_stats[Pfs.STATS.GOALS_REACHED].append(goal_reached)
#
#		# finished?
#		var reached_goals_count: int = bolt_level_stats[Pfs.STATS.GOALS_REACHED].size()
#		# next goal
#		if reached_goals_count < level_profile[\"level_goals\"].size():
##			printt(\"next\", current_level.level_finish)
#			bolt_reaching.bolt_controller.on_goal_reached(goal_reached)
#			Rfs.sound_manager.play_sfx(\"little_horn\")
#		else:
#			# next target finish
#			if current_level.level_finish:
##				print(\"to finish\")
#				bolt_reaching.bolt_controller.on_goal_reached(goal_reached, current_level.level_finish)
#				Rfs.sound_manager.play_sfx(\"little_horn\")
#			# finished
#			else:
##				print(\"finished\")
#				bolt_reaching.bolt_controller.on_goal_reached(goal_reached)
#				Rfs.sound_manager.play_sfx(\"finish_horn\")
#				agents_finished.append(bolt_reaching)
#
#
#func _on_finish_line_crossed(bolt_across: Bolt): # sproži finish line
#
#	if not game_on:
#		return
#
#	var bolt_level_data: Dictionary = level_stats[bolt_across.driver_index]
#	var bolt_goals_reached: Array = bolt_level_data[Pfs.STATS.GOALS_REACHED].duplicate()
#
#	# ne registriram, če niso izpolnjeni pogoji v krogu oz dirki
##	printt(\"stats\", bolt_level_data[Pfs.STATS.GOALS_REACHED])
##	printt(\"level_goals\", bolt_goals_reached, level_profile[\"level_goals\"])
#	if level_profile[\"level_goals\"].size() > 0:
#		if not bolt_goals_reached == level_profile[\"level_goals\"]:
#			return
#
#
#		# najprej preverjam, če level_finish še edini cilj ali pa ni nobenega
##		var goals_reached_size: int = bolt_level_data[Pfs.STATS.GOALS_REACHED].size()
##		printt (\"finish_crosed\", goals_reached_size)
#
##		if bolt_level_data[Pfs.STATS.GOALS_REACHED] == level_profile[\"level_goals\"]:
#
#
#	# stat level time
#	print(\"SDFSDFDFDFSsdf\")
##	var current_level_time: float = hud.game_timer.game_time_hunds
#	var prev_lap_level_time: float = bolt_level_data[Pfs.STATS.LEVEL_TIME]
#	bolt_level_data[Pfs.STATS.LEVEL_TIME] = hud.game_timer.game_time_hunds
#
#	var has_finished_level: bool = false
#	# WITH LAPS ... lap finished če so vsi čekpointi
#	if level_profile[\"lap_limit\"] > 1:
#		var lap_time: float = bolt_level_data[Pfs.STATS.LEVEL_TIME] - prev_lap_level_time
#		bolt_level_data[Pfs.STATS.LAPS_FINISHED].append(lap_time)
#		if bolt_level_data[Pfs.STATS.LAPS_FINISHED].size() >= level_profile[\"lap_limit\"]:
#			has_finished_level = true
#	else:
#		has_finished_level = true
#
#	if has_finished_level:
#		var drive_out_time: float = 1
#		var drive_out_vector: Vector2 = current_level.drive_out_position.rotated(current_level.level_finish.global_rotation)
#		bolt_across.drive_out(drive_out_time, drive_out_vector)
#		agents_finished.append(bolt_across)
#		Rfs.sound_manager.play_sfx(\"finish_horn\")
#	else:
#		Rfs.sound_manager.play_sfx(\"little_horn\")
#
#
#	# hud update
#	for stat_key in [Pfs.STATS.LAPS_FINISHED, Pfs.STATS.BEST_LAP_TIME, Pfs.STATS.LEVEL_TIME, Pfs.STATS.GOALS_REACHED]:
#		hud.update_bolt_level_stats(bolt_across.driver_index, stat_key, bolt_level_data[stat_key])
#
#
#func _on_level_is_set(level_type: int, start_positions: Array, camera_nodes: Array, nav_positions: Array, level_goals: Array):
#
#	level_profile[\"level_type\"] = level_type
#	level_profile[\"level_goals\"] = level_goals.duplicate()
#	# navigacija za AI
#	navigation_positions = nav_positions
#	# random pickable pozicije
#	available_pickable_positions = nav_positions.duplicate()
#	# spawn poz
#	start_position_nodes = start_positions.duplicate()
#	# kamera
#	Rfs.game_camera.setup(camera_nodes[0], camera_nodes[1].global_position) # debug
#
#	printt(\"GM level goals\", level_profile[\"level_goals\"])
#
#
#func _on_body_exited_playing_field(body: Node) -> void:
#
#	#	if body.is_in_group(Rfs.group_agents):
#	if body.is_in_group(Rfs.group_players):
#		_pull_bolt_on_field(body)
#	elif body is Projectile:
#		body.on_out_of_playing_field() # ta funkcija zakasni učinek
#
#
#func _on_bolt_activity_change(changed_bolt: Bolt):
#
#	# preverja, če je še kakšen player aktiven ... za GO
#	if changed_bolt.is_active == false:
#		for bolt in agents_in_game:
#			if bolt.is_active and bolt.is_in_group(Rfs.group_players):
#				return
#		end_level()
"

[sub_resource type="StyleBoxFlat" id=18]
draw_center = false
border_width_left = 4
border_width_top = 4
border_width_right = 4
border_width_bottom = 4

[sub_resource type="StyleBoxFlat" id=19]
draw_center = false
border_width_left = 4
border_width_top = 4
border_width_right = 4
border_width_bottom = 4
border_color = Color( 1, 0.964706, 0.878431, 1 )

[sub_resource type="AudioStreamRandomPitch" id=13]
audio_stream = ExtResource( 32 )

[sub_resource type="AudioStreamRandomPitch" id=15]
audio_stream = ExtResource( 31 )

[sub_resource type="AudioStreamRandomPitch" id=17]
audio_stream = ExtResource( 5 )
random_pitch = 1.05

[node name="Game" type="Node2D"]
script = ExtResource( 2 )

[node name="GameManager" type="Node" parent="."]
script = SubResource( 20 )

[node name="GameViewFlow" type="VFlowContainer" parent="."]
anchor_right = 1.0
anchor_bottom = 1.0
margin_right = 2560.0
margin_bottom = 1440.0
rect_min_size = Vector2( 2560, 1440 )
size_flags_horizontal = 0
size_flags_vertical = 0
custom_constants/vseparation = 10
custom_constants/hseparation = 10

[node name="GameView" parent="GameViewFlow" instance=ExtResource( 1 )]
size_flags_vertical = 1

[node name="GameView2" parent="GameViewFlow" instance=ExtResource( 1 )]
visible = false
margin_left = 2570.0
margin_right = 5130.0

[node name="GameView3" parent="GameViewFlow" instance=ExtResource( 1 )]
visible = false
margin_left = 2570.0
margin_right = 5130.0
size_flags_vertical = 0

[node name="__test_flow" type="HFlowContainer" parent="."]
visible = false
anchor_right = 1.0
anchor_bottom = 1.0
margin_right = 2560.0
margin_bottom = 1444.0
rect_min_size = Vector2( 2560, 1440 )
size_flags_horizontal = 0
size_flags_vertical = 0

[node name="Panel" type="Panel" parent="__test_flow"]
margin_right = 888.0
margin_bottom = 1000.0
rect_min_size = Vector2( 500, 1000 )
size_flags_horizontal = 3
size_flags_vertical = 3
custom_styles/panel = SubResource( 18 )

[node name="Panel2" type="Panel" parent="__test_flow"]
margin_left = 892.0
margin_right = 2560.0
margin_bottom = 1000.0
rect_min_size = Vector2( 1280, 500 )
size_flags_horizontal = 3
size_flags_vertical = 3
custom_styles/panel = SubResource( 18 )

[node name="Panel3" type="Panel" parent="__test_flow"]
margin_top = 1004.0
margin_right = 2560.0
margin_bottom = 1724.0
rect_min_size = Vector2( 1280, 720 )
size_flags_horizontal = 3
custom_styles/panel = SubResource( 18 )

[node name="Panel4" type="Panel" parent="__test_flow"]
visible = false
margin_top = 2422.0
margin_right = 2560.0
margin_bottom = 3142.0
rect_min_size = Vector2( 1280, 720 )
size_flags_horizontal = 3
custom_styles/panel = SubResource( 18 )

[node name="UI" type="Control" parent="."]
margin_right = 2560.0
margin_bottom = 2880.0
__meta__ = {
"_edit_lock_": true
}

[node name="AgentHuds" type="Control" parent="UI"]
margin_right = 2560.0
margin_bottom = 1440.0
script = ExtResource( 10 )

[node name="ViewImitator" type="Control" parent="UI/AgentHuds"]
margin_right = 928.0
margin_bottom = 912.0
rect_clip_content = true

[node name="__ColorRect" type="Panel" parent="UI/AgentHuds/ViewImitator"]
anchor_right = 1.0
anchor_bottom = 1.0
custom_styles/panel = SubResource( 19 )

[node name="AgentHud" parent="UI/AgentHuds/ViewImitator" instance=ExtResource( 12 )]
margin_left = 424.0
margin_top = 512.0
margin_right = 552.0
margin_bottom = 722.0

[node name="_debug" type="Control" parent="UI"]
visible = false
margin_right = 40.0
margin_bottom = 40.0

[node name="label" type="Label" parent="UI/_debug"]
margin_right = 40.0
margin_bottom = 14.0

[node name="label2" type="Label" parent="UI/_debug"]
margin_right = 40.0
margin_bottom = 14.0

[node name="Hud" parent="UI" instance=ExtResource( 8 )]
margin_bottom = -1440.0
__meta__ = {
"_edit_horizontal_guides_": [ 360.0 ],
"_edit_lock_": true,
"_edit_vertical_guides_": [ 640.0, 0.0 ]
}

[node name="PauseGame" parent="UI" instance=ExtResource( 7 )]
visible = false
__meta__ = {
"_edit_horizontal_guides_": [ 488.0 ],
"_edit_lock_": true,
"_edit_vertical_guides_": [ 64.0, 576.0 ]
}

[node name="LevelFinished" parent="UI" instance=ExtResource( 13 )]
visible = false
__meta__ = {
"_edit_lock_": true,
"_edit_vertical_guides_": [ 320.0 ]
}

[node name="GameOver" parent="UI" instance=ExtResource( 3 )]
visible = false
__meta__ = {
"_edit_lock_": true,
"_edit_vertical_guides_": [ 320.0, 1280.0 ]
}

[node name="SoundManager" type="Node" parent="."]
pause_mode = 2
script = ExtResource( 22 )

[node name="GameMusic" type="Node2D" parent="SoundManager"]

[node name="Track8_5" type="AudioStreamPlayer" parent="SoundManager/GameMusic"]
stream = ExtResource( 11 )
volume_db = -10.0
bus = "GameMusic"

[node name="Track4_4" type="AudioStreamPlayer" parent="SoundManager/GameMusic"]
stream = ExtResource( 66 )
volume_db = -6.0
bus = "GameMusic"

[node name="Track12_5" type="AudioStreamPlayer" parent="SoundManager/GameMusic"]
stream = ExtResource( 68 )
volume_db = -6.0
bus = "GameMusic"

[node name="Track1_3" type="AudioStreamPlayer" parent="SoundManager/GameMusic"]
stream = ExtResource( 15 )
volume_db = -7.0
bus = "GameMusic"

[node name="Nitro" type="AudioStreamPlayer" parent="SoundManager/GameMusic"]
stream = ExtResource( 4 )
bus = "GameMusic"

[node name="GuiSfx" type="Node2D" parent="SoundManager"]

[node name="Inputs" type="Node2D" parent="SoundManager/GuiSfx"]

[node name="Typing" type="Node2D" parent="SoundManager/GuiSfx/Inputs"]

[node name="Key1" type="AudioStreamPlayer" parent="SoundManager/GuiSfx/Inputs/Typing"]
stream = ExtResource( 60 )
volume_db = -15.0
pitch_scale = 0.6

[node name="Key2" type="AudioStreamPlayer" parent="SoundManager/GuiSfx/Inputs/Typing"]
stream = ExtResource( 6 )
volume_db = -15.0
pitch_scale = 0.6

[node name="Key3" type="AudioStreamPlayer" parent="SoundManager/GuiSfx/Inputs/Typing"]
stream = ExtResource( 9 )
volume_db = -15.0
pitch_scale = 0.6

[node name="Key4" type="AudioStreamPlayer" parent="SoundManager/GuiSfx/Inputs/Typing"]
stream = ExtResource( 61 )
volume_db = -15.0
pitch_scale = 0.6

[node name="Key5" type="AudioStreamPlayer" parent="SoundManager/GuiSfx/Inputs/Typing"]
stream = ExtResource( 47 )
volume_db = -15.0
pitch_scale = 0.6

[node name="BtnFocus" type="AudioStreamPlayer" parent="SoundManager/GuiSfx/Inputs"]
stream = ExtResource( 38 )
volume_db = -30.0
pitch_scale = 0.7

[node name="BtnConfirm" type="AudioStreamPlayer" parent="SoundManager/GuiSfx/Inputs"]
stream = ExtResource( 36 )
volume_db = -25.0

[node name="BtnCancel" type="AudioStreamPlayer" parent="SoundManager/GuiSfx/Inputs"]
stream = ExtResource( 48 )
volume_db = -25.0

[node name="Events" type="Node2D" parent="SoundManager/GuiSfx"]

[node name="Win" type="AudioStreamPlayer" parent="SoundManager/GuiSfx/Events"]
stream = ExtResource( 29 )
volume_db = -15.0

[node name="Loose" type="AudioStreamPlayer" parent="SoundManager/GuiSfx/Events"]
stream = ExtResource( 65 )
volume_db = -5.0

[node name="GameCoundownA" type="AudioStreamPlayer" parent="SoundManager/GuiSfx/Events"]
stream = ExtResource( 46 )
volume_db = -25.0
pitch_scale = 0.8

[node name="GameCoundownB" type="AudioStreamPlayer" parent="SoundManager/GuiSfx/Events"]
stream = ExtResource( 16 )
volume_db = -15.0
pitch_scale = 0.7

[node name="StartCoundownA" type="AudioStreamPlayer" parent="SoundManager/GuiSfx/Events"]
stream = ExtResource( 46 )
volume_db = -25.0

[node name="StartCoundownB" type="AudioStreamPlayer" parent="SoundManager/GuiSfx/Events"]
stream = ExtResource( 16 )
volume_db = -15.0

[node name="TutorialStageDone" type="AudioStreamPlayer" parent="SoundManager/GuiSfx/Events"]
stream = ExtResource( 53 )
volume_db = -13.0
pitch_scale = 1.1

[node name="MenuFade" type="AudioStreamPlayer" parent="SoundManager/GuiSfx"]
stream = ExtResource( 21 )
volume_db = -15.0
pitch_scale = 0.93

[node name="ScreenSlide" type="AudioStreamPlayer" parent="SoundManager/GuiSfx"]
stream = ExtResource( 20 )
pitch_scale = 0.9

[node name="Sfx" type="Node" parent="SoundManager"]

[node name="BigHorn" type="AudioStreamPlayer" parent="SoundManager/Sfx"]
stream = ExtResource( 34 )
volume_db = 5.0
pitch_scale = 0.8
bus = "GameSfx"

[node name="LittleHorn" type="AudioStreamPlayer" parent="SoundManager/Sfx"]
stream = ExtResource( 34 )
bus = "GameSfx"

[node name="BulletHit" type="AudioStreamPlayer" parent="SoundManager/Sfx"]
stream = SubResource( 13 )
volume_db = -15.0
pitch_scale = 0.7
bus = "GameSfx"

[node name="BoltExplode" type="AudioStreamPlayer" parent="SoundManager/Sfx"]
stream = ExtResource( 33 )
volume_db = -10.0
bus = "GameSfx"

[node name="ShockerEffect" type="AudioStreamPlayer" parent="SoundManager/Sfx"]
stream = ExtResource( 24 )
volume_db = -16.0
bus = "GameSfx"

[node name="Pickable" type="AudioStreamPlayer" parent="SoundManager/Sfx"]
stream = ExtResource( 27 )
volume_db = -15.0
bus = "GameSfx"

[node name="PickableAmmo" type="AudioStreamPlayer" parent="SoundManager/Sfx"]
stream = ExtResource( 25 )
volume_db = -15.0
pitch_scale = 1.2
bus = "GameSfx"

[node name="PickableNitro" type="AudioStreamPlayer" parent="SoundManager/Sfx"]
stream = ExtResource( 28 )
volume_db = -10.0
bus = "GameSfx"

[node name="LevelSounds" type="Node" parent="SoundManager"]

[node name="HitBullet" type="AudioStreamPlayer" parent="SoundManager/LevelSounds"]
stream = SubResource( 15 )
volume_db = -10.0
pitch_scale = 0.9
bus = "GameSfx"

[node name="HitBulletBrick" type="AudioStreamPlayer" parent="SoundManager/LevelSounds"]
stream = ExtResource( 41 )
volume_db = 11.513
bus = "GameSfx"

[node name="HitMisile" type="AudioStreamPlayer" parent="SoundManager/LevelSounds"]
stream = SubResource( 17 )
volume_db = -10.0
bus = "GameSfx"

[node name="Nitro" type="AudioStreamPlayer" parent="SoundManager/LevelSounds"]
stream = ExtResource( 35 )
volume_db = -15.0
bus = "GameSfx"

[node name="DeNitro" type="AudioStreamPlayer" parent="SoundManager/LevelSounds"]
stream = ExtResource( 39 )
volume_db = -15.0
bus = "GameSfx"

[node name="MagnetIn" type="AudioStreamPlayer" parent="SoundManager/LevelSounds"]
stream = ExtResource( 40 )
volume_db = -10.0
bus = "GameSfx"

[node name="MagnetLoop" type="AudioStreamPlayer" parent="SoundManager/LevelSounds"]
stream = ExtResource( 37 )
volume_db = -10.0
bus = "GameSfx"

[node name="MagnetOut" type="AudioStreamPlayer" parent="SoundManager/LevelSounds"]
stream = ExtResource( 42 )
volume_db = -10.0
bus = "GameSfx"

[node name="Music" type="Node" parent="SoundManager"]

[node name="_ni vec tuki" type="Node2D" parent="SoundManager"]

[node name="MisileShoot" type="AudioStreamPlayer" parent="SoundManager/_ni vec tuki"]
stream = ExtResource( 17 )
bus = "GameSfx"

[node name="MisileFlight" type="AudioStreamPlayer" parent="SoundManager/_ni vec tuki"]
stream = ExtResource( 14 )
bus = "GameSfx"

[node name="MisileDetect" type="AudioStreamPlayer" parent="SoundManager/_ni vec tuki"]
stream = ExtResource( 19 )
bus = "GameSfx"

[node name="BulletShoot2" type="AudioStreamPlayer" parent="SoundManager/_ni vec tuki"]
stream = ExtResource( 23 )
bus = "GameSfx"

[node name="MisileExplode" type="AudioStreamPlayer" parent="SoundManager/_ni vec tuki"]
stream = ExtResource( 18 )
bus = "GameSfx"
